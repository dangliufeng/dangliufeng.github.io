<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java 语法糖，你用过几个？</title>
    <url>/2024/09/12/Java%E8%AF%AD%E6%B3%95%E7%B3%96/</url>
    <content><![CDATA[<h1 id="Java-语法糖，你用过几个？"><a href="#Java-语法糖，你用过几个？" class="headerlink" title="Java 语法糖，你用过几个？"></a>Java 语法糖，你用过几个？</h1><h2 id="什么是语法糖？"><a href="#什么是语法糖？" class="headerlink" title="什么是语法糖？"></a>什么是语法糖？</h2><p>语法糖()</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>后端开发</category>
        <category>DevOps实践</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>编程语言</tag>
        <tag>后端开发</tag>
        <tag>编程技巧</tag>
        <tag>DevOps</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2024/08/27/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>Personal</category>
      </categories>
      <tags>
        <tag>Introduction</tag>
        <tag>Welcome</tag>
      </tags>
  </entry>
  <entry>
    <title>让你Docker从入门到精通</title>
    <url>/2024/08/28/%E8%AE%A9%E4%BD%A0Docker%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/</url>
    <content><![CDATA[<h1 id="Docker-学习笔记"><a href="#Docker-学习笔记" class="headerlink" title="Docker 学习笔记"></a>Docker 学习笔记</h1><p>[toc]</p>
<h2 id="Docker-简介"><a href="#Docker-简介" class="headerlink" title="Docker 简介"></a>Docker 简介</h2><p>虚拟机（Virtual Machine，简称VM）的发展，减轻了企业对硬件资源的依赖，它将一台物理设备虚拟为多个逻辑设备，每个逻辑设备可运行不同的操作系统，并且应用程序都可以在相互独立的空间内运行而互不影响，从而显著提高设备的工作效率。然而，传统VM需要安装操作系统才能执行应用程序，占用系统资源过多。多数情况下，用户只需要运行简单的应用程序，采用VM技术操作繁琐且造成资源浪费。倘若需要迁移应用服务程序，则需迁移整个VM，因此企业迫切需要轻量级的虚拟化技术。</p>
<p><strong>容器</strong>，就是一种<strong>轻量级</strong>的虚拟化技术，目的和虚拟机一样，都是为了创造 <strong>“隔离环境”</strong> 。但是它不像VM采用操作系统级的<strong>资源隔离</strong>，容器采用的是进程级的<strong>系统隔离</strong>。</p>
<p>容器虚拟化技术化常见的有：Kubernetes（K8s）、Podman、LXC、Rkt、Docker等。基于这个容器的优缺点，我经常使用的是docker。它的优点如下：</p>
<ul>
<li><strong>轻量级和高效</strong>： Docker 利用容器技术，与传统的虚拟机相比，它们共享主机操作系统的内核，因此更为轻量级和高效。Docker 容器启动快速，占用资源较少，能够在短时间内快速部署和销毁。</li>
<li><strong>一致的开发和运行环境</strong>： Docker 提供了一种标准化的打包和交付机制，开发者可以将应用程序及其所有依赖项打包到一个 Docker 镜像中。这种镜像可以在开发、测试和生产环境中一致地运行，消除了由环境差异引起的问题，确保了应用程序的一致性和可移植性。</li>
<li><strong>快速部署和扩展</strong>： Docker 容器可以快速部署到任何支持 Docker 的主机上，并且可以轻松地进行水平扩展。Docker 提供了简单而强大的容器编排工具（如 Docker Swarm 和 Kubernetes），使得多个容器的管理和扩展变得更加简单和高效。</li>
<li><strong>环境隔离和安全性</strong>： 每个 Docker 容器都是相互隔离的，有自己的文件系统、进程空间和网络接口，可以避免应用程序之间的冲突和影响。这种隔离性有助于提高应用程序的安全性，并减少了安全漏洞的风险。</li>
<li><strong>持续集成和持续部署的支持</strong>： Docker 可以与现代的 CI&#x2F;CD 工具集成，自动化构建、测试和部署流程。这使得开发团队能够更快速、可靠地交付新版本的应用程序，提高了软件开发和部署的效率和质量。</li>
<li><strong>开放和生态系统</strong>： Docker 是一个开源项目，并且有一个活跃的社区支持和贡献。它的开放性使得用户可以自由地扩展和定制 Docker 平台，同时有许多第三方工具和服务与 Docker 集成，进一步丰富了其功能和应用场景。</li>
</ul>
<h2 id="Docker常用网站"><a href="#Docker常用网站" class="headerlink" title="Docker常用网站"></a>Docker常用网站</h2><p>常用网站:</p>
<ol>
<li><a href="http://www.docker.com/">docker官网</a></li>
<li><a href="https://www.dockerdocs.cn/index.html">docker中文网</a></li>
<li><a href="https://hub.docker.com/">docker hub</a></li>
<li><a href="https://docs.docker.com/">docker文档</a></li>
</ol>
<p>安装 Docker 引擎版请参考 <a href="https://docs.docker.com/engine/install/">Docker 引擎版安装指南</a></p>
<h2 id="Docker三要素"><a href="#Docker三要素" class="headerlink" title="Docker三要素"></a>Docker三要素</h2><ul>
<li><strong>镜像（Image）</strong> ：镜像是 Docker 容器的模板，包含应用程序和运行环境。通过镜像，可以在不同环境中创建一致的容器。</li>
<li><strong>容器（Container）</strong> ：容器是镜像的运行实例，包含应用程序及其依赖。容器彼此隔离，但共享主机的操作系统内核。</li>
<li><strong>仓库（Repository）</strong> ：仓库用于存储和分发镜像。Docker Hub 是一个公共的镜像仓库，用户可以从中下载和上传镜像。</li>
</ul>
<p><img src="https://489m41372l.vicp.fun/blog/github/1.png" alt="image-20240614105028338.png"></p>
<p>废话不多说我们马上来上手来安装<strong>Docker</strong>吧！</p>
<h2 id="安装Docker–centos7示例"><a href="#安装Docker–centos7示例" class="headerlink" title="安装Docker–centos7示例"></a>安装Docker–centos7示例</h2><p><strong>前置条件</strong> ：安装之前首先需要准备一个centos7的虚拟机并且可以连接到网络。</p>
<ol>
<li><p>更新系统软件包首确保所有软件包都是最新的（可选） <code>sudo yum update -y</code></p>
</li>
<li><p>安装必要的依赖包</p>
<p><code>sudo yum install -y yum-utils device-mapper-persistent-data lvm2</code></p>
</li>
<li><p>添加 Docker 仓库</p>
<p><code>sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</code></p>
</li>
<li><p>安装 Docker</p>
<p><code>sudo yum install -y docker-ce docker-ce-cli containerd.io</code></p>
</li>
<li><p>启动 Docker 服务并设置开机自启动</p>
<p><code>sudo systemctl start docker</code> <code>sudo systemctl enable docker</code></p>
</li>
<li><p>验证 Docker 安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo docker run hello-world </span><br></pre></td></tr></table></figure></li>
</ol>
<p>安装成功以后可以看到以下信息</p>
<ol start="7">
<li><p>添加用户到 Docker 组</p>
<p>为了避免每次运行 Docker 命令都使用 <code>sudo</code>，可以将当前用户添加到 Docker 组：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo usermod -aG docker $USER</span><br></pre></td></tr></table></figure>

<p>然后退出并重新登录，或使用 <code>newgrp docker</code> 命令刷新组成员身份。</p>
</li>
<li><p>配置 Docker 镜像加速</p>
<p>为加速 Docker 镜像下载，可以配置国内的镜像源，例如使用阿里云加速器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://&lt;your-mirror-url&gt;&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br><span class="line">&lt;!-- 国内常见镜像源--&gt;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [</span><br><span class="line">  &quot;https://********.mirror.aliyuncs.com&quot;, //阿里云加速器</span><br><span class="line">  &quot;https://dockerproxy.com&quot;,//DockerProxy</span><br><span class="line">  &quot;https://mirror.baidubce.com&quot;,//百度云加速器:</span><br><span class="line">  &quot;https://docker.m.daocloud.io&quot;,//DaoCloud加速器</span><br><span class="line">  &quot;https://docker.nju.edu.cn&quot;,//南京大学加速器</span><br><span class="line">  &quot;https://docker.mirrors.sjtug.sjtu.edu.cn&quot;//上海交通大学加速器</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="Docker底层原理"><a href="#Docker底层原理" class="headerlink" title="Docker底层原理"></a>Docker底层原理</h2><h3 id="到底什么是Docker？Docker-是怎么工作的？"><a href="#到底什么是Docker？Docker-是怎么工作的？" class="headerlink" title="到底什么是Docker？Docker 是怎么工作的？"></a>到底什么是Docker？Docker 是怎么工作的？</h3><p><code>Docker是一个Client-Server结构的系统，Docker守护进程运行在主机上， 然后通过Socket连接从客户端访问Docker守护进程。Docker守护进程从客户端接受命令，并按照命令，管理运行在主机上的容器。</code></p>
<p>Docker 通过使用 Linux 容器技术，提供了一种轻量级的虚拟化解决方案。以下是 Docker 的工作原理概述：</p>
<ol>
<li><p><strong>Namespaces（命名空间）</strong> ：</p>
<ul>
<li>Docker 使用 Linux 的命名空间（Namespaces）技术来实现资源隔离。每个容器都有自己的网络、进程、挂载点、UTS（主机名）和 IPC（进程间通信）命名空间。这些命名空间确保了容器之间的隔离，使得一个容器中的操作不会影响到其他容器。</li>
</ul>
</li>
<li><p><strong>Control Groups（控制组，Cgroups）</strong> ：</p>
<ul>
<li>控制组（Cgroups）是 Linux 内核提供的另一种功能，用于限制、记录和隔离进程组的资源（CPU、内存、磁盘I&#x2F;O、网络等）使用情况。Docker 使用 Cgroups 来管理每个容器可以使用的资源，确保容器之间的资源分配和使用不会相互干扰。</li>
</ul>
</li>
<li><p><strong>Union File Systems（联合文件系统，UnionFS）</strong> ：</p>
<ul>
<li>Docker 利用联合文件系统（如 AUFS、OverlayFS、Btrfs 等）来实现高效的存储层。UnionFS 允许多个文件系统层叠加在一起，形成一个单一的可用文件系统。Docker 镜像由多层组成，每层都可以看作是一个只读的文件系统，容器运行时的写操作会创建一个新的可写层（容器层）。这种层次结构使得镜像的共享和复用变得非常高效。</li>
</ul>
</li>
<li><p><strong>Container Runtime（容器运行时）</strong> ：</p>
<ul>
<li>Docker 使用容器运行时来管理容器的生命周期。Docker 最初使用的是自带的运行时（libcontainer），现在则是基于 OCI 标准的 runc。运行时负责创建和启动容器，并使用上面提到的命名空间和控制组来实现隔离和资源控制。</li>
</ul>
</li>
<li><p><strong>Docker Daemon（守护进程）</strong> ：</p>
<ul>
<li>Docker 守护进程（dockerd）是 Docker 引擎的核心组件，负责处理 Docker API 请求、管理镜像和容器、网络、数据卷等。客户端（如 Docker CLI 或其他工具）通过与 Docker 守护进程通信来管理容器。</li>
</ul>
</li>
<li><p><strong>Docker 镜像和容器</strong>：</p>
<ul>
<li>Docker 镜像是容器的蓝图，包含了运行应用程序所需的一切（代码、库、配置文件等）。Docker 容器是镜像的运行实例，每个容器都是一个独立的进程，具有自己的文件系统、网络接口和资源限制。</li>
</ul>
</li>
</ol>
<p><img src="https://489m41372l.vicp.fun/blog/github/2.png" alt="1718675370435.jpg"></p>
<h3 id="Docker为什么比VM虚拟机快"><a href="#Docker为什么比VM虚拟机快" class="headerlink" title="Docker为什么比VM虚拟机快"></a>Docker为什么比VM虚拟机快</h3><p>Docker 相对于传统的虚拟机有显著的性能优势，主要原因如下：</p>
<ol>
<li><p><strong>共享主机操作系统内核</strong>：</p>
<ul>
<li>Docker 容器共享主机操作系统的内核，而虚拟机则需要运行一个完整的客操作系统。共享内核减少了内存和 CPU 的开销，提高了资源利用效率。</li>
</ul>
</li>
<li><p><strong>轻量级的进程隔离</strong>：</p>
<ul>
<li>Docker 使用的是进程级别的隔离技术，而虚拟机需要虚拟化整个硬件环境。这使得 Docker 容器的启动和停止速度非常快，通常只需几秒钟甚至几毫秒，而虚拟机则需要几分钟。</li>
</ul>
</li>
<li><p><strong>更高的资源利用率</strong>：</p>
<ul>
<li>由于 Docker 容器不需要为每个实例分配固定的资源（如 CPU、内存等），而是通过控制组动态管理，这使得资源利用率更高。虚拟机通常需要预分配资源，即使未完全使用，资源也会被占用。</li>
</ul>
</li>
<li><p><strong>高效的存储层</strong>：</p>
<ul>
<li>Docker 的联合文件系统使得镜像的存储和传输非常高效。只需下载和存储不同层的差异部分即可，这相比虚拟机需要完整的磁盘镜像文件要高效得多。</li>
</ul>
</li>
<li><p><strong>一致的环境</strong>：</p>
<ul>
<li><p>Docker 提供了一致的运行环境，消除了开发、测试和生产环境之间的差异，减少了环境配置和依赖问题，从而提高了开发和部署的效率。</p>
<p>| 特性     | 容器     | 虚拟机   |<br> | ——– | ——– | ——– |<br>| 启动速度 | 秒级     | 分钟级   |<br>| 硬盘使用 | 一般为MB | 一般为GB |<br>| 性能     | 接近原生 | 弱于原生 |</p>
</li>
</ul>
</li>
</ol>
<p>Docker 虽然在许多方面优于传统的虚拟机（VM），但也存在一些缺点：</p>
<ol>
<li><strong>操作系统依赖性</strong>：</li>
</ol>
<ul>
<li>Docker 容器共享宿主机的操作系统内核，这意味着容器化的应用程序必须与宿主机的操作系统兼容。如果应用程序依赖于特定版本或配置的操作系统，容器化可能会面临限制或兼容性问题。</li>
</ul>
<ol start="2">
<li><strong>安全性</strong>：</li>
</ol>
<ul>
<li>虽然 Docker 提供了一定程度的隔离性，但容器共享相同的内核和部分系统资源，这可能导致容器间的安全漏洞扩散。相比之下，虚拟机能够提供更加彻底的隔离，每个虚拟机都有自己的完整操作系统。</li>
</ul>
<ol start="3">
<li><strong>性能开销</strong>：</li>
</ol>
<ul>
<li>Docker 容器在运行时不需要启动整个操作系统，因此通常比虚拟机启动更快并且资源消耗更少。然而，Docker 容器仍然有一定的性能开销，尤其是在涉及密集的计算或需要大量 I&#x2F;O 操作时，性能可能不如直接在物理或虚拟机上运行的应用程序。</li>
</ul>
<ol start="4">
<li><strong>持久化存储</strong>：</li>
</ol>
<ul>
<li>Docker 容器默认情况下使用的是可写的容器层（Container Layer），这些层不适合长期存储或大量写入操作。虽然可以通过数据卷（Volumes）或者其他存储解决方案来解决这个问题，但这增加了部署和管理的复杂性。</li>
</ul>
<ol start="5">
<li><strong>复杂性和学习曲线</strong>：</li>
</ol>
<ul>
<li>虽然 Docker 提供了强大的功能和灵活性，但学习如何正确地使用 Docker 和管理容器化应用程序需要一定的学习和适应时间。尤其是对于复杂的网络配置、容器编排和持续集成&#x2F;持续部署（CI&#x2F;CD）流程，需要额外的专业知识和经验。</li>
</ul>
<ol start="6">
<li><strong>依赖于外部服务</strong>：</li>
</ol>
<ul>
<li>使用 Docker 需要依赖于 Docker Hub 或者其他容器镜像仓库来获取和管理镜像。如果依赖的镜像源不稳定或者出现问题，可能会影响到应用程序的部署和运行。</li>
</ul>
<h2 id="Docker常用命令"><a href="#Docker常用命令" class="headerlink" title="Docker常用命令"></a>Docker常用命令</h2><h3 id="容器管理"><a href="#容器管理" class="headerlink" title="容器管理"></a>容器管理</h3><ul>
<li><p><strong>docker ps</strong> 查看当前正在运行的容器。</p>
</li>
<li><p><strong>docker create <container_id or container_name></strong> ** 创建容器</p>
</li>
<li><p><strong>docker ps -a</strong> 查看所有容器，包括已停止的。</p>
</li>
<li><p><strong>docker start <container_id or container_name></strong> 启动一个停止状态的容器。</p>
</li>
<li><p><strong>docker stop <container_id or container_name></strong> 停止一个运行中的容器。</p>
</li>
<li><p><strong>docker restart <container_id or container_name></strong> 重启一个容器。</p>
</li>
<li><p><strong>docker pause <container_id or container_name></strong></p>
<p>暂停一个或多个正在运行的容器中的所有进程。</p>
</li>
<li><p><strong>docker rm <container_id or container_name></strong> 删除一个停止状态的容器。</p>
</li>
<li><p><strong>docker logs <container_id or container_name></strong> 查看容器的日志。</p>
</li>
<li><p><strong>docker exec -it <container_id or container_name> &#x2F;bin&#x2F;bash</strong> 进入正在运行的容器内部的交互式 shell。</p>
</li>
</ul>
<h3 id="镜像管理"><a href="#镜像管理" class="headerlink" title="镜像管理"></a>镜像管理</h3><ul>
<li><strong>docker images</strong> 查看本地所有的镜像。</li>
<li><strong>docker pull <a href="">image_name:tag</a></strong> 拉取一个镜像到本地。</li>
<li><strong>docker build -t <a href="">image_name:tag</a> <Dockerfile_path></strong> 根据 Dockerfile 构建一个镜像。</li>
<li><strong>docker rmi <image_id or image_name:tag></strong> 删除一个本地的镜像。</li>
<li><strong>docker tag <image_id> <a href="">new_image_name:tag</a></strong> 给镜像打标签。</li>
</ul>
<h3 id="网络管理"><a href="#网络管理" class="headerlink" title="网络管理"></a>网络管理</h3><ul>
<li><strong>docker network ls</strong> 列出所有 Docker 网络。</li>
<li><strong>docker network inspect <network_id or network_name></strong> 查看指定 Docker 网络的详细信息。</li>
<li><strong>docker network create <network_name></strong> 创建一个新的 Docker 网络。</li>
<li><strong>docker network connect <network_id or network_name> <container_id or container_name></strong> 连接容器到指定的网络。</li>
</ul>
<h3 id="数据卷管理"><a href="#数据卷管理" class="headerlink" title="数据卷管理"></a>数据卷管理</h3><ul>
<li><strong>docker volume ls</strong> 列出所有 Docker 数据卷。</li>
<li><strong>docker volume create <volume_name></strong> 创建一个新的 Docker 数据卷。</li>
<li><strong>docker volume inspect <volume_name></strong> 查看指定 Docker 数据卷的详细信息。</li>
<li><strong>docker volume rm <volume_name></strong> 删除一个 Docker 数据卷。</li>
</ul>
<h3 id="其他常用命令"><a href="#其他常用命令" class="headerlink" title="其他常用命令"></a>其他常用命令</h3><ul>
<li><strong>docker info</strong> 查看 Docker 系统信息，包括容器和镜像的数量等。</li>
<li><strong>docker version</strong> 查看 Docker 版本信息。</li>
<li><strong>docker-compose up</strong> 使用 Docker Compose 启动应用程序。</li>
<li><strong>docker-compose down</strong> 使用 Docker Compose 停止并移除容器、网络和数据卷。</li>
</ul>
<h2 id="Docker镜像原理"><a href="#Docker镜像原理" class="headerlink" title="Docker镜像原理"></a>Docker镜像原理</h2><p>镜像是一种轻量级、可执行的独立软件包， 用来打包软件运行环境和基于运行环境开发的软件 ，它包含运行某个软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件。  Docker镜像基础是UnionFS联合文件系统，一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层叠加，同时可以将不同目录挂载到同一个虚拟文件系统下，镜像可以通过分层来进行继承，基于继承镜像可以制作各种具体的应用镜像。  特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录。</p>
<h3 id="1-镜像结构"><a href="#1-镜像结构" class="headerlink" title="1. 镜像结构"></a>1. 镜像结构</h3><p>Docker 镜像是一个多层文件系统，每一层都是一个只读文件系统。这些层次结构被称为联合文件系统（UnionFS），允许将多个文件系统层叠在一起，形成一个单一的逻辑文件系统。</p>
<h3 id="2-分层结构"><a href="#2-分层结构" class="headerlink" title="2. 分层结构"></a>2. 分层结构</h3><p>Docker 镜像的每一层都是一个文件系统的快照，包含了构成镜像的文件和目录。每个镜像都有一个基础层（Base Layer），在其基础上可以叠加多个只读层。</p>
<h3 id="3-镜像加载过程"><a href="#3-镜像加载过程" class="headerlink" title="3. 镜像加载过程"></a>3. 镜像加载过程</h3><p>当使用 <code>docker run</code> 命令启动一个容器时，Docker 容器运行时会执行以下步骤来加载镜像：</p>
<ul>
<li><strong>查找镜像：</strong> Docker 首先检查本地是否已经存在所需镜像。如果本地不存在，它会从默认的镜像注册表（如 Docker Hub）下载镜像。</li>
<li><strong>创建容器层：</strong> Docker 创建一个新的容器层（Container Layer），这是一个可写的层，用于存储容器运行时的所有变更和修改。这个层是镜像层的顶部。</li>
<li><strong>联合文件系统：</strong> Docker 将镜像的各个只读层和容器层通过联合文件系统（UnionFS）技术进行联合挂载。这样，容器就能够看到镜像中所有层次的文件系统，但只能修改和操作容器层上的文件系统。</li>
<li><strong>启动容器进程：</strong> 最后，Docker 启动容器中定义的进程，该进程在容器的隔离环境中运行。这个进程可以访问整个联合文件系统，并且只能在容器层进行写操作。</li>
</ul>
<h3 id="4-优势和效率"><a href="#4-优势和效率" class="headerlink" title="4. 优势和效率"></a>4. 优势和效率</h3><p>Docker 镜像加载的这种分层结构和联合文件系统带来了以下优势：</p>
<ul>
<li><strong>资源共享和节约：</strong> 多个容器可以共享相同的基础层（Base Layer），节省存储空间和带宽。</li>
<li><strong>高效构建和部署：</strong> Docker 可以快速创建和销毁容器，因为它只需在容器层上应用变更，而不必重新复制整个镜像。</li>
<li><strong>可复用性和版本控制：</strong> 镜像的分层结构允许开发人员创建和管理不同版本的镜像，并在不同环境中重复使用。</li>
</ul>
<p>Docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS。  bootfs(boot file system)主要包含bootloader和kernel, bootloader主要是引导加载kernel, Linux刚启动时会加载bootfs文件系统， 在Docker镜像的最底层是bootfs。 这一层与我们典型的Linux&#x2F;Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs。</p>
<p>rootfs (root file system) ，在bootfs之上 。包含的就是典型 Linux 系统中的 &#x2F;dev, &#x2F;proc, &#x2F;bin, &#x2F;etc 等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu，Centos等等。</p>
<h3 id="Docker镜像加载原理："><a href="#Docker镜像加载原理：" class="headerlink" title="Docker镜像加载原理："></a><strong>Docker镜像加载原理：</strong></h3><p>Docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS。  bootfs(boot file system)主要包含bootloader和kernel, bootloader主要是引导加载kernel, Linux刚启动时会加载bootfs文件系统， 在Docker镜像的最底层是bootfs。 这一层与我们典型的Linux&#x2F;Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs。 rootfs (root file system) ，在bootfs之上 。包含的就是典型 Linux 系统中的 &#x2F;dev, &#x2F;proc, &#x2F;bin, &#x2F;etc 等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu，Centos等等。</p>
<p>平时我们安装进虚拟机的CentOS都是好几个G，为什么docker这里才200M？？ 对于一个精简的OS，rootfs可以很小，只需要包括最基本的命令、工具和程序库就可以了，因为底层直接用Host的kernel，自己只需要提供 rootfs 就行了。由此可见对于不同的linux发行版, bootfs基本是一致的, rootfs会有差别, 因此不同的发行版可以公用bootfs。 平时我们安装进</p>
<p>虚拟机的CentOS都是好几个G，为什么docker这里才200M？？ 对于一个精简的OS，rootfs可以很小，只需要包括最基本的命令、工具和程序库就可以了，因为底层直接用Host的kernel，自己只需要提供 rootfs 就行了。由此可见对于不同的linux发行版, bootfs基本是一致的, rootfs会有差别, 因此不同的发行版可以公用bootfs。</p>
<h3 id="Docker分层结构的优势"><a href="#Docker分层结构的优势" class="headerlink" title="Docker分层结构的优势"></a><strong>Docker分层结构的优势</strong></h3><p>最大的一个好处就是 - 共享资源 比如：有多个镜像都从相同的 base 镜像构建而来，那么宿主机只需在磁盘上保存一份base镜像，同时内存中也只需加载一份 base 镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。 <strong>Docker镜像</strong>都是<strong>只读</strong>的，当容器启动时，一个新的可写层被加载到镜像的顶部。这一层通常被称作“容器层”，“容器层”之下的都叫“镜像层”。</p>
<h3 id="从容器生成镜像"><a href="#从容器生成镜像" class="headerlink" title="从容器生成镜像"></a><strong>从容器生成镜像</strong></h3><ul>
<li><p><strong>docker commit -m&#x3D;“提交的描述信息” -a&#x3D;“作者” 容器ID 要创建的目标镜像名:[标签名]</strong></p>
<p><code>docker commit -m=&quot;DLF commit test&quot; -a=&quot;DLF&quot; a2ec9eb0e4f3 helloword:v1</code></p>
</li>
</ul>
<p><img src="https://489m41372l.vicp.fun/blog/github/3.png" alt="image-20240618102758218.png"></p>
<h2 id="数据共享–容器数据卷"><a href="#数据共享–容器数据卷" class="headerlink" title="数据共享–容器数据卷"></a>数据共享–容器数据卷</h2><p>为了能让docker容器产生的数据，如果不做特殊处理，容器删除后，数据也会被删除，可以通过commit或者docker cp这种笨重的方式保存，但更便捷的方法是创建数据卷。 docker容器数据卷有以下特点：</p>
<ol>
<li>数据卷可在容器之间共享或重用数据</li>
<li>卷中的更改可以直接生效</li>
<li>数据卷中的更改不会包含在镜像的更新中</li>
<li>数据卷的生命周期一直持续到没有容器使用它为止</li>
<li>数据卷允许容器数据持久化到宿主机上</li>
</ol>
<h3 id="命令创建容器数据卷"><a href="#命令创建容器数据卷" class="headerlink" title="命令创建容器数据卷"></a><strong>命令创建容器数据卷</strong></h3><ul>
<li>docker run -it -v &#x2F;宿主机绝对路径目录:&#x2F;容器内目录 镜像名:镜像标签</li>
</ul>
<p>可以使用docker inspect 查看是否创建成功</p>
<p><img src="https://489m41372l.vicp.fun/blog/github/4.png" alt="image-20240618103323922.png"><br>上述命令可增加读写权限：  docker run -it -v &#x2F;宿主机绝对路径目录:&#x2F;容器内目录:ro 镜像名:镜像标签  <strong>需要注意</strong>的是，-v主机目录的方式，在dockerfile中不能直接使用，由于宿主机是不同的，每个宿主机都不一样，不能保证所有的宿 主机上都存在这样的特定目录。</p>
<h3 id="使用dockerfile创建容器数据卷"><a href="#使用dockerfile创建容器数据卷" class="headerlink" title="使用dockerfile创建容器数据卷"></a><strong>使用dockerfile创建容器数据卷</strong></h3><p>在dockerfile中使用VOLUME指令来给镜像添加一个或多个数据卷</p>
<p>Dockerfile:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 基于官方的 Ubuntu 镜像作为基础镜像</span><br><span class="line">FROM ubuntu:latest</span><br><span class="line"># 设置工作目录</span><br><span class="line">WORKDIR /app</span><br><span class="line"># 在 Dockerfile 中声明多个数据卷</span><br><span class="line">VOLUME [&quot;/app/data1&quot;, &quot;/app/data2&quot;]</span><br><span class="line"># 设置容器启动时执行的命令</span><br><span class="line">CMD [&quot;bash&quot;]</span><br></pre></td></tr></table></figure>

<p>进入Dockerfile所在目录<code>docker build -t myimage .</code></p>
<p><strong>使用 <code>VOLUME</code> 指令声明的数据卷默认情况下是匿名的，即不会显示具体的宿主机路径，但会显示容器内路径。如果你希望在容器运行时能够看到宿主机路径，需要在运行容器时使用 <code>-v</code> 参数来显式挂载。</strong></p>
<p><code>docker run -it -v /host/path/data1:/app/data1 -v /host/path/data2:/app/data2 myimage</code></p>
<p>查看<code>` docker inspect 容器ID</code></p>
<p><img src="https://489m41372l.vicp.fun/blog/github/5.png" alt="image-20240618111111078.png"></p>
<h2 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h2><p>命名的容器挂载数据卷，其它容器通过挂载这个(父容器)实现数据共享，挂载数据卷的容器，称之为数据卷容器 ，数据卷的生命周期一直持续到没有容器使用它为止。</p>
<p>我们可以使用上面dockerfile构建的镜像，先启动一个容器myimage,然后再使用以下命令启动两个容器dlf2和dlf1，能看到都有共同的数据卷，在里面创建的文件，再返回myimage查看能被看到：</p>
<p><code>docker run -it --name dlf1 --volumes-from 3f457cfbe5e5 myimage</code></p>
<p><code>docker run -it --name dlf2 --volumes-from 3f457cfbe5e5 myimage</code></p>
<p><img src="https://489m41372l.vicp.fun/blog/github/6.png" alt="image-20240618112300250.png"></p>
<p><img src="https://489m41372l.vicp.fun/blog/github/7.png" alt="image-20240618112326425.png"></p>
<p><img src="https://489m41372l.vicp.fun/blog/github/8.png" alt="image-20240618112336122.png"></p>
<h2 id="Dockerfile解析"><a href="#Dockerfile解析" class="headerlink" title="Dockerfile解析"></a>Dockerfile解析</h2><p>Dockerfile是用来构建Docker镜像的构建文件，是由一系列命令和参数构成的脚本。 可以理解成可以一键构建镜像的脚本，编写完dockerfile后，docker build 产出镜像，docker run运行镜像</p>
<p>以下是Centos7Dockerfile请参考</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FROM scratch</span><br><span class="line">ADD centos-7-x86_64-docker.tar.xz /</span><br><span class="line"></span><br><span class="line">LABEL \</span><br><span class="line">    org.label-schema.schema-version=&quot;1.0&quot; \</span><br><span class="line">    org.label-schema.name=&quot;CentOS Base Image&quot; \</span><br><span class="line">    org.label-schema.vendor=&quot;CentOS&quot; \</span><br><span class="line">    org.label-schema.license=&quot;GPLv2&quot; \</span><br><span class="line">    org.label-schema.build-date=&quot;20201113&quot; \</span><br><span class="line">    org.opencontainers.image.title=&quot;CentOS Base Image&quot; \</span><br><span class="line">    org.opencontainers.image.vendor=&quot;CentOS&quot; \</span><br><span class="line">    org.opencontainers.image.licenses=&quot;GPL-2.0-only&quot; \</span><br><span class="line">    org.opencontainers.image.created=&quot;2020-11-13 00:00:00+00:00&quot;</span><br><span class="line"></span><br><span class="line">CMD [&quot;/bin/bash&quot;]</span><br></pre></td></tr></table></figure>

<h3 id="Dockerfile语法规则"><a href="#Dockerfile语法规则" class="headerlink" title="Dockerfile语法规则"></a><strong>Dockerfile语法规则</strong></h3><ol>
<li>每条保留字指令都必须为大写字母，且后面要跟随至少一个参数</li>
<li>指令按照从上到下，顺序执行</li>
<li>#表示注释</li>
<li>每条指令都会创建一个新的镜像层，并对镜像进行提交</li>
</ol>
<h3 id="Docker执行Dockerfile的大致流程"><a href="#Docker执行Dockerfile的大致流程" class="headerlink" title="Docker执行Dockerfile的大致流程"></a><strong>Docker执行Dockerfile的大致流程</strong></h3><ol>
<li>docker 从基础镜像运行一个容器</li>
<li>执行一条指令并对容器作出修改</li>
<li>执行类似docker commit的操作提交一个新的镜像层</li>
<li>基于刚提交的镜像运行一个新的容器</li>
<li>执行dockerfile中的下一条指令直到所有指令都执行完成</li>
</ol>
<h3 id="一张图展示dockerfile-image-container等之间关系"><a href="#一张图展示dockerfile-image-container等之间关系" class="headerlink" title="一张图展示dockerfile,image,container等之间关系"></a>一张图展示dockerfile,image,container等之间关系</h3><p><img src="https://489m41372l.vicp.fun/blog/github/9.png" alt="image-20240618113252050.png"></p>
<h2 id="Docker容器编排"><a href="#Docker容器编排" class="headerlink" title="Docker容器编排"></a>Docker容器编排</h2><p>一般来说，我们每一个容器中只运行一个服务，多个服务时通常需要其他措施来对多个服务保活。因为docker容器本身占用资源极少,所以最好是将每个服务单独的分割开来但是这样我们又面临了一个问题？</p>
<p>如果我需要同时部署好多个服务,难道要每个服务单独写Dockerfile然后在构建镜像,构建容器,这样累都累死了,所以docker官方给我们提供了docker-compose多服务部署的工具 ，可以管理多个 Docker 容器组成一个应用。你需要定义一个 YAML 格式的配置文件docker-compose.yml， 写好多个容器之间的调用关系 。然后，只要一个命令，就能同时启动&#x2F;关闭这些容器</p>
<p>例如要实现一个Web微服务项目，除了Web服务容器本身，往往还需要再加上后端的数据库mysql服务容器，redis服务器，注册中心eureka，甚至还包括负载均衡容器等等。。。。。。</p>
<p>Compose允许用户通过一个单独的 docker-compose.yml模板文件 （YAML 格式）来定义 一组相关联的应用容器为一个项目（project）。</p>
<p>可以很容易地用一个配置文件定义一个多容器的应用，然后使用一条指令安装这个应用的所有依赖，完成构建。Docker-Compose 解决了容器与容器之间如何管理编排的问题。</p>
<p>安装地址：<a href="https://docs.docker.com/compose/install/linux/#install-the-plugin-manually">https://docs.docker.com/compose/install/linux/#install-the-plugin-manually</a></p>
<p><strong>使用步骤</strong></p>
<ol>
<li>编写Dockerfile定义各个微服务应用并构建出对应的镜像文件</li>
<li>使用 docker-compose.yml 定义一个完整业务单元，安排好整体应用中的各个容器服务。</li>
<li>最后，执行docker-compose up命令 来启动并运行整个应用程序，完成一键部署上线</li>
</ol>
<p><strong>常用命令</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Compose 常用命令</span><br><span class="line">docker-compose -h # 查看帮助</span><br><span class="line">docker-compose up # 启动所有 docker-compose服务</span><br><span class="line">docker-compose up -d # 启动所有 docker-compose服务 并后台运行</span><br><span class="line">docker-compose down # 停止并删除容器、网络、卷、镜像。</span><br><span class="line">docker-compose exec yml里面的服务id # 进入容器实例内部 docker-compose exec docker-compose.yml文件中写的服务id /bin/bash</span><br><span class="line">docker-compose ps # 展示当前docker-compose编排过的运行的所有容器</span><br><span class="line">docker-compose top # 展示当前docker-compose编排过的容器进程</span><br><span class="line"></span><br><span class="line">docker-compose logs yml里面的服务id # 查看容器输出日志</span><br><span class="line">docker-compose config # 检查配置</span><br><span class="line">docker-compose config -q # 检查配置，有问题才有输出</span><br><span class="line">docker-compose restart # 重启服务</span><br><span class="line">docker-compose start # 启动服务</span><br><span class="line">docker-compose stop # 停止服务</span><br></pre></td></tr></table></figure>

<p>安装docker-compose</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">下载 Docker Compose：</span><br><span class="line">sudo curl -L &quot;https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose</span><br><span class="line">赋予执行权限：</span><br><span class="line">sudo chmod +x /usr/local/bin/docker-compose</span><br><span class="line">验证安装：</span><br><span class="line">docker-compose --version</span><br></pre></td></tr></table></figure>

<h3 id="docker-compose案例"><a href="#docker-compose案例" class="headerlink" title="docker-compose案例"></a>docker-compose案例</h3><p>首先在docker路径下创建以上文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@bogon docker]# ls</span><br><span class="line">default.conf  docker-compose.yml  nginx.conf  website</span><br><span class="line">[root@bogon docker]# pwd</span><br><span class="line">/docker</span><br></pre></td></tr></table></figure>

<p><strong>nginx.conf</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># nginx.conf</span><br><span class="line"></span><br><span class="line">user nginx;</span><br><span class="line">worker_processes auto;</span><br><span class="line">error_log /var/log/nginx/error.log;</span><br><span class="line">pid /run/nginx.pid;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections 1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include /etc/nginx/mime.types;</span><br><span class="line">    default_type application/octet-stream;</span><br><span class="line"></span><br><span class="line">    log_format main &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br><span class="line">                      &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br><span class="line">                      &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><br><span class="line"></span><br><span class="line">    access_log /var/log/nginx/access.log main;</span><br><span class="line"></span><br><span class="line">    sendfile on;</span><br><span class="line">    tcp_nopush on;</span><br><span class="line">    tcp_nodelay on;</span><br><span class="line"></span><br><span class="line">    keepalive_timeout 65;</span><br><span class="line"></span><br><span class="line">    include /etc/nginx/conf.d/*.conf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>docker-compose.yml</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">version: &#x27;3&#x27;</span><br><span class="line">services:</span><br><span class="line">  nginx:</span><br><span class="line">    image: nginx:latest</span><br><span class="line">    container_name: nginx-container</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;80:80&quot;</span><br><span class="line">    volumes:</span><br><span class="line">      - ./default.conf:/etc/nginx/conf.d/default.conf</span><br><span class="line">      - ./website:/usr/share/nginx/html</span><br><span class="line">    restart: always</span><br></pre></td></tr></table></figure>

<p><strong>default.conf</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># default.conf</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;          # Listen on port 80 for incoming HTTP requests</span><br><span class="line">    server_name example.com;  # Server name that this block will respond to</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        root /usr/share/nginx/html;  # Root directory for serving static files</span><br><span class="line">        index index.html;            # Default file to serve if none specified</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>&#x2F;docker&#x2F;website&#x2F;index.html</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;&lt;body&gt;Hello, Docker!&lt;/body&gt;&lt;/html&gt;</span><br></pre></td></tr></table></figure>


<p><img src="https://489m41372l.vicp.fun/blog/github/10.png" alt="image-20240618123029300.png"></p>
<p>最后输入<a href="http://192.168.56.102/">http://192.168.56.102/</a>就可以查看到网页了</p>
<p><img src="https://489m41372l.vicp.fun/blog/github/11.png" alt="image-20240618123109978.png"></p>
<p><strong>在容器数量较少的场景下</strong>，我们docker-compose工具已经够用，但如果<strong>容器数量较多</strong>的情况下，我们就需要用一个更便捷的管理工具<strong>k8s</strong>了。</p>
]]></content>
      <categories>
        <category>云计算</category>
        <category>运维</category>
        <category>DevOps工具</category>
      </categories>
      <tags>
        <tag>DevOps</tag>
        <tag>云技术</tag>
        <tag>Linux</tag>
        <tag>Docker</tag>
        <tag>容器技术</tag>
      </tags>
  </entry>
  <entry>
    <title>轻量级的日志系统</title>
    <url>/2024/08/28/%E8%BD%BB%E9%87%8F%E7%BA%A7%E7%9A%84%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="轻量级日志系统-Loki-Loki4j-Grafana-实践"><a href="#轻量级日志系统-Loki-Loki4j-Grafana-实践" class="headerlink" title="轻量级日志系统(Loki + Loki4j + Grafana)实践"></a>轻量级日志系统(Loki + Loki4j + Grafana)实践</h1><h2 id="常见的日志监控系统"><a href="#常见的日志监控系统" class="headerlink" title="常见的日志监控系统"></a>常见的日志监控系统</h2><p>平时在构建日志管理系统时，传统的、重量级的ELK Stack当仁不让,除了它之外还有几个常见的选择：</p>
<ul>
<li><p><strong>Splunk</strong>:</p>
<ul>
<li>强大的商业日志管理和分析平台，提供实时搜索、监控和警报功能。</li>
<li>用户界面友好，适用于大规模的日志数据收集和分析需求。</li>
</ul>
</li>
<li><p><strong>Graylog</strong>:</p>
<ul>
<li>开源的日志管理平台，支持实时流式处理和数据分析。</li>
<li>提供强大的搜索和可视化功能，适合中小型企业和开发团队使用。</li>
</ul>
</li>
<li><p><strong>Fluentd</strong>:</p>
<ul>
<li>开源的数据收集器，设计用于大规模数据流处理。</li>
<li>支持灵活的数据传输和转换，可以与多种数据存储系统集成。</li>
</ul>
</li>
<li><p><strong>Prometheus + Grafana</strong>:</p>
<ul>
<li><p>Prometheus是一个开源的监控和警报工具，专注于时序数据的收集和存储。</p>
</li>
<li><p>Grafana作为其可视化和仪表板工具，与Prometheus紧密集成，用于监控数据的可视化展示。</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><em>我今天实践的是由<strong>Grafana Labs</strong>开发的日志聚合系统，它专注于高效率地收集和存储日志，使用标签而不是索引来组织日志数据，使其在大规模环境中更具可扩展性（轻量级）。想我这种叼毛的服务器装上Elasticsearch+Kibana基本就.gg了别说运行程序了了。</em></p>
</blockquote>
<h2 id="所需组件简介"><a href="#所需组件简介" class="headerlink" title="所需组件简介"></a>所需组件简介</h2><p>想要使用轻量级日志系统（Loki + Loki4j + Grafana），首先要理解每个组件的作用和优势：</p>
<h3 id="什么是-Loki？"><a href="#什么是-Loki？" class="headerlink" title="什么是 Loki？"></a>什么是 Loki？</h3><blockquote>
<p><strong>Loki</strong> 是由Grafana Labs开发的开源日志聚合系统，专为高效处理和可视化大规模分布式系统的日志数据而设计。与传统的日志系统不同，Loki使用标签索引而非传统的文档索引存储日志数据，这种方式提升了查询效率和存储效率，尤其适合大规模环境的应用。</p>
</blockquote>
<h3 id="什么是Loki4j？"><a href="#什么是Loki4j？" class="headerlink" title="什么是Loki4j？"></a>什么是Loki4j？</h3><blockquote>
<p><strong>Loki4j</strong> 是专为Java应用程序设计的日志库，用于将应用程序的日志数据发送到Loki服务器。它提供简单的API接口，使得在Java应用中集成Loki变得更加便捷高效，充分利用Loki的强大存储和检索能力。</p>
</blockquote>
<h3 id="什么是Grafana？"><a href="#什么是Grafana？" class="headerlink" title="什么是Grafana？"></a>什么是Grafana？</h3><p>当谈论Grafana时，可以将其描述为一个强大且灵活的开源数据可视化和监控平台。它最初是为了监控系统指标而开发的，但现在已经发展成为支持多种数据源的广泛应用工具。</p>
<blockquote>
<p><strong>Grafana</strong> 是一款开源的数据分析和可视化平台，最初用于监控数据展示和分析。现在，Grafana不仅支持各种数据源（如时序数据库、日志数据库、关系型数据库等），还提供丰富的图表选项和仪表板配置，用户可以通过简单的拖拽操作快速创建和定制监控和分析场景。Grafana还拥有强大的警报功能，帮助用户实时响应数据异常情况。</p>
</blockquote>
<h2 id="实践过程"><a href="#实践过程" class="headerlink" title="实践过程"></a>实践过程</h2><h3 id="1-安装Loki和Grafana"><a href="#1-安装Loki和Grafana" class="headerlink" title="1. 安装Loki和Grafana"></a>1. 安装Loki和Grafana</h3><pre><code>[root@bogon ~]# docker run -d --name loki -p 3100:3100 grafana/loki:latest -config.file=/etc/loki/local-config.yaml
[root@bogon ~]# docker run -d --name grafana -p 3000:3000 grafana/grafana:latest
</code></pre>
<p>有需要的可以将配置、数据和日志文件保存到宿主机。</p>
<blockquote>
<p>grafana组件安装好后可以过127.0.0.1:3000进入操作页面，默认账号密码:admin。</p>
</blockquote>
<p>登录成功以后可以先测试连接loki测试是否连通</p>
<ol>
<li>进入Data Source页面Add data source</li>
</ol>
<p><img src="https://489m41372l.vicp.fun/blog/github/12.png" alt="image-20240619172307402.png"></p>
<p><img src="https://489m41372l.vicp.fun/blog/github/13.png" alt="image-20240619172415963.png"></p>
<ol start="2">
<li>点击后输入框搜索Loki后点击填写数据，填写完成后点击Save &amp; test后</li>
</ol>
<p><img src="https://489m41372l.vicp.fun/blog/github/14.png" alt="image-20240619174025971.png"></p>
<h3 id="2-配置Loki4j"><a href="#2-配置Loki4j" class="headerlink" title="2. 配置Loki4j"></a>2. 配置Loki4j</h3><p><strong>引入jar包</strong></p>
<blockquote>
<pre><code>&lt;dependency&gt;
 &lt;groupId&gt;com.github.loki4j&lt;/groupId&gt;
 &lt;artifactId&gt;loki-logback-appender&lt;/artifactId&gt;
 &lt;version&gt;1.4.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
</blockquote>
<p><strong>在src&#x2F;main&#x2F;resources下创建logback.xml</strong></p>
<blockquote>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;configuration&gt;
 &lt;!-- 引入Spring应用名称 --&gt;
 &lt;springProperty scope=&quot;context&quot; name=&quot;name&quot; source=&quot;spring.application.name&quot;/&gt;
 &lt;!-- 控制台输出器 --&gt;
 &lt;appender name=&quot;CONSOLE&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;
     &lt;encoder&gt;
         &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [thread %thread] %-5level %logger&#123;36&#125;.%method - $&#123;name&#125; - %msg%n&lt;/pattern&gt;
     &lt;/encoder&gt;
 &lt;/appender&gt;

 &lt;!-- Loki输出器 --&gt;
 &lt;appender name=&quot;LOKI&quot; class=&quot;com.github.loki4j.logback.Loki4jAppender&quot;&gt;
     &lt;http&gt;
         &lt;url&gt;http://192.168.56.102:3100/loki/api/v1/push&lt;/url&gt;
     &lt;/http&gt;
     &lt;format&gt;
         &lt;label&gt;
             &lt;pattern&gt;application=$&#123;name&#125;,level=%level&lt;/pattern&gt;
             &lt;readMarkers&gt;true&lt;/readMarkers&gt;
         &lt;/label&gt;
         &lt;message&gt;
             &lt;pattern&gt;
                 &#123;&quot;timestamp&quot;: &quot;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;&quot;, &quot;level&quot;: &quot;%level&quot;, &quot;logger&quot;: &quot;%logger&#123;36&#125;.%method&quot;, &quot;method&quot;:&quot;%M&quot;, &quot;line&quot;:&quot;%line&quot;, &quot;thread&quot;: &quot;%thread&quot;, &quot;message&quot;: &quot;%msg%n&quot;&#125;
             &lt;/pattern&gt;
         &lt;/message&gt;
         &lt;sortByTime&gt;true&lt;/sortByTime&gt;
     &lt;/format&gt;
 &lt;/appender&gt;

 &lt;root level=&quot;INFO&quot;&gt;
     &lt;appender-ref ref=&quot;CONSOLE&quot;/&gt;
     &lt;appender-ref ref=&quot;LOKI&quot;/&gt;
 &lt;/root&gt;

&lt;/configuration&gt;
</code></pre>
</blockquote>
<p>在 <strong>application.yml</strong>中</p>
<blockquote>
<pre><code>spring:
application:
 name: blog
</code></pre>
</blockquote>
<p>配置完成后运行程序就可以去garafana查看日志了</p>
<h3 id="3-查看日志"><a href="#3-查看日志" class="headerlink" title="3. 查看日志"></a>3. 查看日志</h3><p>进入garafana按照步骤就可以查看日志了</p>
<p><img src="https://489m41372l.vicp.fun/blog/github/15.png" alt="image-20240619230211998.png"><br>此外Loki还支持<a href="https://grafana.com/docs/loki/latest/reference/loki-http-api/">HTTP API</a>的形式操作数据,具体的可以看官网文档。</p>
]]></content>
      <categories>
        <category>Java开发</category>
        <category>日志管理</category>
        <category>DevOps工具</category>
        <category>监控与可视化</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>Loki</tag>
        <tag>Loki4j</tag>
        <tag>Grafana</tag>
        <tag>日志管理</tag>
        <tag>可视化</tag>
        <tag>监控工具</tag>
      </tags>
  </entry>
  <entry>
    <title>React学习</title>
    <url>/2024/09/20/React%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="React学习"><a href="#React学习" class="headerlink" title="React学习"></a>React学习</h1><h2 id="React-概述"><a href="#React-概述" class="headerlink" title="React 概述"></a>React 概述</h2><h3 id="什么是React？"><a href="#什么是React？" class="headerlink" title="什么是React？"></a>什么是React？</h3><p>​	React 是一个用于<strong>构建用户界面</strong>的 <strong>JavaScript 库</strong>，主要用于开发 HTML 页面和构建 Web 应用。如果从MVC的角度来看，React仅仅是视图层（V），也就是只负责试图的渲染，而并未提供了完整的M（Model模型）和C（Controller控制器）的功能。React 起源于 Facebook 的内部项目。最初用于构建 Instagram 的网站。并React 于 2013 年 5 月正式开源。</p>
<h3 id="React的特点"><a href="#React的特点" class="headerlink" title="React的特点"></a>React的特点</h3><ul>
<li>声明式编程</li>
<li>基于组件</li>
<li>JSX 语法</li>
<li>单向数据流</li>
<li>跨平台开发</li>
<li>高效的开发体验</li>
<li>声明式 UI</li>
</ul>
<h2 id="React-的基本使用"><a href="#React-的基本使用" class="headerlink" title="React 的基本使用"></a>React 的基本使用</h2><h3 id="安装React"><a href="#安装React" class="headerlink" title="安装React"></a>安装React</h3><p>打开项目终端</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm i react react-dom</span><br></pre></td></tr></table></figure>

<h3 id="React的使用"><a href="#React的使用" class="headerlink" title="React的使用"></a>React的使用</h3><p><img src="https://489m41372l.vicp.fun/blog/github/16.png" alt="16.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>01-react基本使用<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span> =<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!-- 1 引入js文件 --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./node_modules/react/umd/react.development.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./node_modules/react-dom/umd/react-dom.development.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!-- 2 创建React元素 --&gt;</span></span><br><span class="line">     <span class="comment">&lt;!-- 参数一：元素名称</span></span><br><span class="line"><span class="comment">     参数二：元素属性</span></span><br><span class="line"><span class="comment">     参数三：元素内容 --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">     <span class="keyword">const</span> title = <span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;h1&#x27;</span>, &#123;<span class="attr">title</span>:<span class="string">&#x27;标题&#x27;</span>&#125;, <span class="string">&#x27;Hello React&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">     <span class="comment">// 3 将元素渲染到页面</span></span></span><br><span class="line"><span class="language-javascript">     <span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(title, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>))</span></span><br><span class="line"><span class="language-javascript">     </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><img src="https://489m41372l.vicp.fun/blog/github/26.png" alt="26.png"></p>
<h2 id="React-脚手架的使用"><a href="#React-脚手架的使用" class="headerlink" title="React 脚手架的使用"></a>React 脚手架的使用</h2><h3 id="使用React脚手架初始化项目"><a href="#使用React脚手架初始化项目" class="headerlink" title="使用React脚手架初始化项目"></a>使用React脚手架初始化项目</h3><p>1、初始化项目命令：<code>npx create-react-app myapp</code></p>
<p>2、启动项目，在项目根目录下执行命令：<code>yarn start</code> 启动成功后会自动打开浏览器</p>
<p>启动成功页面：</p>
<p><img src="https://489m41372l.vicp.fun/blog/github/17.png" alt="17.png"></p>
<h3 id="在脚手架中使用React"><a href="#在脚手架中使用React" class="headerlink" title="在脚手架中使用React"></a>在脚手架中使用React</h3><p>src&#x2F;index.js删除原来内容并写入下面代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 1.引入React和ReactDOM（ES6模块化语法导入）</span><br><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import ReactDOM from &#x27;react-dom&#x27;;</span><br><span class="line">// 2.创建组件</span><br><span class="line">const title = React.createElement(&#x27;h1&#x27;, &#123;title:&#x27;一级标题&#x27;&#125;, &#x27;Hello world!&#x27;);</span><br><span class="line">// 3.渲染组件(脚手架一级组件为root不用自己创建)</span><br><span class="line">ReactDOM.render(title, document.getElementById(&#x27;root&#x27;));</span><br></pre></td></tr></table></figure>

<p>效果：<img src="https://489m41372l.vicp.fun/blog/github/18.png" alt="image-20240812152343006" style="zoom:25%;" /></p>
<h2 id="jsx学习"><a href="#jsx学习" class="headerlink" title="jsx学习"></a>jsx学习</h2><h3 id="什么是JSX"><a href="#什么是JSX" class="headerlink" title="什么是JSX?"></a>什么是JSX?</h3><p>​	JSX（JavaScript XML）是一种 JavaScript 的语法扩展，主要用于在 React 中描述用户界面（UI）的结构。它看起来很像 HTML，但它实际上是在 JavaScript 中编写的代码。JSX 是 React 中构建组件的主要方式，能够让开发者以一种更加直观的方式定义 UI。</p>
<h3 id="JSX的基本使用"><a href="#JSX的基本使用" class="headerlink" title="JSX的基本使用"></a>JSX的基本使用</h3><p>src&#x2F;index.js</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 1.引入React和ReactDOM</span><br><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import ReactDOM from &#x27;react-dom&#x27;;</span><br><span class="line">// 2.创建JSX组件</span><br><span class="line">const title = (&lt;h1&gt;Hello, &lt;span&gt;JSX&lt;/span&gt;&lt;/h1&gt;)</span><br><span class="line">// 3.渲染组件</span><br><span class="line">ReactDOM.render(title, document.getElementById(&#x27;root&#x27;));</span><br></pre></td></tr></table></figure>

<p>效果展示：<img src="https://489m41372l.vicp.fun/blog/github/19.png" alt="image-20240812153322378" style="zoom: 50%;" /></p>
<h3 id="JSX的注意点"><a href="#JSX的注意点" class="headerlink" title="JSX的注意点"></a>JSX的注意点</h3><ul>
<li>React元素的属性名使用驼峰命名法。</li>
<li>特殊属性名：class-&gt; classNmae、for-&gt;htmlFor、tabindex-&gt;tabIndex。</li>
<li>没有子节点的React元素可以使用&#x2F;&gt;结束。</li>
<li>推荐：使用小括号包裹JSX,从而避免JS中的自动插入分号陷阱。</li>
</ul>
<h3 id="在JSX中使用JS表达式"><a href="#在JSX中使用JS表达式" class="headerlink" title="在JSX中使用JS表达式"></a>在JSX中使用JS表达式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 1.引入React和ReactDOM</span><br><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import ReactDOM from &#x27;react-dom&#x27;;</span><br><span class="line">// 2.创建JSX组件</span><br><span class="line">const name = &#x27;linhao&#x27;</span><br><span class="line">const title = (&lt;h1&gt;Hello, &lt;span&gt;&#123;name&#125;&lt;/span&gt;&lt;/h1&gt;)</span><br><span class="line">// 3.渲染组件</span><br><span class="line">ReactDOM.render(title, document.getElementById(&#x27;root&#x27;));</span><br></pre></td></tr></table></figure>

<p>效果：<img src="https://489m41372l.vicp.fun/blog/github/20.png" alt="image-20240812154027373" style="zoom:25%;" /></p>
<h3 id="JSX的条件渲染"><a href="#JSX的条件渲染" class="headerlink" title="JSX的条件渲染"></a>JSX的条件渲染</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import ReactDOM from &#x27;react-dom&#x27;;</span><br><span class="line">const isLoading = true</span><br><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @returns 条件渲染</span><br><span class="line"> */</span><br><span class="line">// const loadData = ()=&gt;&#123;</span><br><span class="line">//   if(isLoading)&#123;</span><br><span class="line">//     return &lt;div&gt;loading...&lt;/div&gt;</span><br><span class="line">//   &#125;</span><br><span class="line">//     return &lt;div&gt;数据加载完成&lt;/div&gt;  </span><br><span class="line">// &#125;</span><br><span class="line">//  ------------------------------------------------------------------------</span><br><span class="line">/**</span><br><span class="line"> * 三元表达式</span><br><span class="line"> */</span><br><span class="line">// const loadData = ()=&gt;&#123;</span><br><span class="line">//   return isLoading ? &lt;div&gt;loading...&lt;/div&gt;: &lt;div&gt;数据加载完成&lt;/div&gt;</span><br><span class="line">// &#125;</span><br><span class="line">//  ------------------------------------------------------------------------</span><br><span class="line">/**</span><br><span class="line"> * 逻辑运算符</span><br><span class="line"> */</span><br><span class="line">const loadData = ()=&gt;&#123;</span><br><span class="line">    return isLoading &amp;&amp; (&lt;div&gt;loading...&lt;/div&gt;)</span><br><span class="line">&#125;</span><br><span class="line">const title = (&lt;h1&gt;</span><br><span class="line">条件渲染：&#123;loadData()&#125;</span><br><span class="line">&lt;/h1&gt;)</span><br><span class="line">ReactDOM.render(title, document.getElementById(&#x27;root&#x27;));</span><br></pre></td></tr></table></figure>

<h3 id="JSX的列表渲染"><a href="#JSX的列表渲染" class="headerlink" title="JSX的列表渲染"></a>JSX的列表渲染</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import ReactDOM from &#x27;react-dom&#x27;;</span><br><span class="line">const songs = [</span><br><span class="line">  &#123;id: 1,name: &#x27;刘德华&#x27;&#125;,</span><br><span class="line">  &#123;id: 2,name: &#x27;王德发&#x27;&#125;,</span><br><span class="line">  &#123;id: 3,name: &#x27;刘德网&#x27;&#125;,</span><br><span class="line">]</span><br><span class="line">const title = (&lt;ul&gt;</span><br><span class="line"> &#123;songs.map(item =&gt;&lt;li key=&#123;item.id&#125;&gt;&#123;item.name&#125;&lt;/li&gt;)&#125; </span><br><span class="line">&lt;/ul&gt;)</span><br><span class="line">ReactDOM.render(title, document.getElementById(&#x27;root&#x27;));</span><br></pre></td></tr></table></figure>

<h3 id="JSX的样式处理"><a href="#JSX的样式处理" class="headerlink" title="JSX的样式处理"></a>JSX的样式处理</h3><h4 id="行内样式-Style"><a href="#行内样式-Style" class="headerlink" title="行内样式(Style)"></a>行内样式(Style)</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import ReactDOM from &#x27;react-dom&#x27;;</span><br><span class="line">const title = (&lt;h1 style=&#123;&#123;color: &#x27;red&#x27; ,backgroundColor: &#x27;skyblue&#x27;&#125;&#125;&gt; JSX的行内样式处理&lt;/h1&gt;)</span><br><span class="line">ReactDOM.render(title, document.getElementById(&#x27;root&#x27;));</span><br></pre></td></tr></table></figure>

<h4 id="类名-className"><a href="#类名-className" class="headerlink" title="类名(className)"></a>类名(className)</h4><p>src&#x2F;index.js</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import ReactDOM from &#x27;react-dom&#x27;;</span><br><span class="line">import &#x27;./css/index.css&#x27;;</span><br><span class="line">const title = (&lt;h1 className=&#x27;title&#x27;&gt; JSX的行内样式处理&lt;/h1&gt;)</span><br><span class="line">ReactDOM.render(title, document.getElementById(&#x27;root&#x27;));</span><br></pre></td></tr></table></figure>

<p>src&#x2F;css&#x2F;index.css</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.title&#123;</span><br><span class="line">    text-align: center;</span><br><span class="line">    color: #0084ff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="React组件"><a href="#React组件" class="headerlink" title="React组件"></a>React组件</h2><h3 id="React组件创建方式"><a href="#React组件创建方式" class="headerlink" title="React组件创建方式"></a>React组件创建方式</h3><h4 id="函数组件创建"><a href="#函数组件创建" class="headerlink" title="函数组件创建"></a>函数组件创建</h4><p>注意点：</p>
<ol>
<li>函数名称必须大写字母开头</li>
<li>函数组件必须有返回值，表示该组件的结构</li>
<li>若返回值为null时，则表示不渲染任何内容</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import ReactDOM from &#x27;react-dom&#x27;;</span><br><span class="line">// function Hello()&#123;</span><br><span class="line">//   return &lt;h1 &gt;这是一个函数组件&lt;/h1&gt;</span><br><span class="line">// &#125;</span><br><span class="line">const Hello = () =&gt; &lt;h1&gt;这是一个函数组件&lt;/h1&gt;;;</span><br><span class="line">ReactDOM.render(&lt;Hello /&gt;, document.getElementById(&#x27;root&#x27;));</span><br></pre></td></tr></table></figure>

<h4 id="类组件创建"><a href="#类组件创建" class="headerlink" title="类组件创建"></a>类组件创建</h4><p>注意点：</p>
<ol>
<li>类名称必须大写字母开头</li>
<li>类组件必须继承React.Component父类。从而可以使用父类中提供的方法或属性</li>
<li>类组件必须提供render()方法</li>
<li>render()方法必须有返回值，表示该组件的结构</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import ReactDOM from &#x27;react-dom&#x27;;</span><br><span class="line">class Hello extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;div&gt;这是一个继承React.Component的类组件&lt;/div&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(&lt;Hello /&gt;, document.getElementById(&#x27;root&#x27;));</span><br></pre></td></tr></table></figure>

<h4 id="抽离为单独的js文件"><a href="#抽离为单独的js文件" class="headerlink" title="抽离为单独的js文件"></a>抽离为单独的js文件</h4><p>src&#x2F;js&#x2F;Hello.js</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React from &quot;react&quot;;</span><br><span class="line">class Hello extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        Hello Class Component</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">export default Hello;</span><br></pre></td></tr></table></figure>

<p>src&#x2F;index.js</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import ReactDOM from &#x27;react-dom&#x27;;</span><br><span class="line">// 1引入Hello.js文件</span><br><span class="line">import Hello from &#x27;./js/Hello&#x27;;</span><br><span class="line">// 2渲染Hello.js中的组件</span><br><span class="line">ReactDOM.render(&lt;Hello /&gt;, document.getElementById(&#x27;root&#x27;));</span><br></pre></td></tr></table></figure>

<h3 id="React-的事件处理"><a href="#React-的事件处理" class="headerlink" title="React 的事件处理"></a>React 的事件处理</h3><h4 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h4><p>注意点：</p>
<ol>
<li>语法：on+事件名称&#x3D;{事件处理程序}，比如onClick&#x3D;{() &#x3D;&gt; {}}</li>
<li>React事件采用驼峰命名法，比如：onClick、onDoubleClick等</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import ReactDOM from &#x27;react-dom&#x27;;</span><br><span class="line">class App extends React.Component &#123;</span><br><span class="line">  handleClick = () =&gt; &#123;</span><br><span class="line">    console.log(&#x27;单击事件&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;button onClick=&#123;this.handleClick&#125;&gt;点我&lt;/button&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(&lt;App /&gt;, document.getElementById(&#x27;root&#x27;));</span><br></pre></td></tr></table></figure>

<h4 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import ReactDOM from &#x27;react-dom&#x27;;</span><br><span class="line">class App extends React.Component &#123;</span><br><span class="line">  handleClick = (e) =&gt; &#123;</span><br><span class="line">    e.preventDefault()</span><br><span class="line">    console.log(&#x27;事件对象&#x27;, e)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;a onClick=&#123;this.handleClick&#125;&gt;a标签&lt;/a&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(&lt;App /&gt;, document.getElementById(&#x27;root&#x27;));</span><br></pre></td></tr></table></figure>

<h3 id="有状态组件和无状态组件"><a href="#有状态组件和无状态组件" class="headerlink" title="有状态组件和无状态组件"></a>有状态组件和无状态组件</h3><ul>
<li>函数组件叫做无状态组件，类组件叫做有状态组件（状态（state）就是数据）</li>
<li>函数组件没有自己的状态，只负责数据展示（静）</li>
<li>类组件有自己的状态，负责更新UI，让页面“动”起来</li>
<li>状态(state)是组件内部的私有数据，只能组件内部使用</li>
<li>state的值是对象，表示一个组件中可以有多个数据</li>
</ul>
<p>计数器案例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import ReactDOM from &#x27;react-dom&#x27;;</span><br><span class="line">class App extends React.Component &#123;</span><br><span class="line">  // 初始化state</span><br><span class="line">  // constructor() &#123;</span><br><span class="line">  //   super();</span><br><span class="line">  //   this.state = &#123;</span><br><span class="line">  //     count: 0,</span><br><span class="line">  //   &#125;;</span><br><span class="line">  // &#125;</span><br><span class="line">  //简写</span><br><span class="line">  state =&#123;</span><br><span class="line">    count: 0,</span><br><span class="line">  &#125;</span><br><span class="line">  handleClick=()=&gt;&#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      count: this.state.count + 1,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;&lt;h1&gt;计数器：&#123;this.state.count&#125;&lt;/h1&gt;</span><br><span class="line">      &lt;button onClick=&#123;this.handleClick&#125;&gt;count++&lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(&lt;App /&gt;, document.getElementById(&#x27;root&#x27;));</span><br></pre></td></tr></table></figure>

<h3 id="事件绑定this指向"><a href="#事件绑定this指向" class="headerlink" title="事件绑定this指向"></a>事件绑定this指向</h3><h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><p>利用箭头函数自身不绑定this的特点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import ReactDOM from &#x27;react-dom&#x27;;</span><br><span class="line">class App extends React.Component &#123;</span><br><span class="line">  state =&#123;</span><br><span class="line">    count: 0,</span><br><span class="line">  &#125;</span><br><span class="line">  handleClick()&#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      count: this.state.count + 1,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;&lt;h1&gt;计数器：&#123;this.state.count&#125;&lt;/h1&gt;</span><br><span class="line">      &lt;button onClick=&#123;()=&gt;this.handleClick()&#125;&gt;count++&lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(&lt;App /&gt;, document.getElementById(&#x27;root&#x27;));</span><br></pre></td></tr></table></figure>

<h4 id="bind方法"><a href="#bind方法" class="headerlink" title="bind方法"></a>bind方法</h4><p>利用ES5中的bind方法，将事件处理方法中的this与组件绑定在椅子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import ReactDOM from &#x27;react-dom&#x27;;</span><br><span class="line">class App extends React.Component &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    super();</span><br><span class="line">    this.handleClick = this.handleClick.bind(this);</span><br><span class="line">    this.state = &#123;count: 0&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  handleClick()&#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      count: this.state.count + 1,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;&lt;h1&gt;计数器：&#123;this.state.count&#125;&lt;/h1&gt;</span><br><span class="line">      &lt;button onClick=&#123;this.handleClick&#125;&gt;count++&lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(&lt;App /&gt;, document.getElementById(&#x27;root&#x27;));</span><br></pre></td></tr></table></figure>

<h4 id="class的实例方法"><a href="#class的实例方法" class="headerlink" title="class的实例方法"></a>class的实例方法</h4><p>其实本质还是箭头函数只是使用的箭头函数的<strong>class实例</strong>方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import ReactDOM from &#x27;react-dom&#x27;;</span><br><span class="line">class App extends React.Component &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    super();</span><br><span class="line">    this.state = &#123;count: 0&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  handleClick=()=&gt;&#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      count: this.state.count + 1,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;&lt;h1&gt;计数器：&#123;this.state.count&#125;&lt;/h1&gt;</span><br><span class="line">      &lt;button onClick=&#123;this.handleClick&#125;&gt;count++&lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(&lt;App /&gt;, document.getElementById(&#x27;root&#x27;));</span><br></pre></td></tr></table></figure>

<h3 id="React表单处理"><a href="#React表单处理" class="headerlink" title="React表单处理"></a>React表单处理</h3><h4 id="受控组件"><a href="#受控组件" class="headerlink" title="受控组件"></a>受控组件</h4><p>受控组件：组件值收到React 控制的表单元素（state和setState()）</p>
<p>表单受控组件示例：</p>
<ul>
<li>给表单元素添加name属性，名称与state相同</li>
<li>根据表单元素获取对应值，</li>
<li>在change事件中通过[name] 修改对应值</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import ReactDOM from &#x27;react-dom&#x27;;</span><br><span class="line">class App extends React.Component &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    super();</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      txt: &#x27;&#x27;,</span><br><span class="line">      checkbox: false,</span><br><span class="line">      textarea:&#x27;&#x27;,</span><br><span class="line">      city:&#x27;sh&#x27;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  handleChange=(e)=&gt;&#123;</span><br><span class="line">    const target = e.target;</span><br><span class="line">    const value = target.type === &#x27;checkbox&#x27; ? target.checked : target.value;</span><br><span class="line">    const name = target.name;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      [name]: value,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input type=&quot;text&quot; name=&#x27;txt&#x27; value=&#123;this.state.txt&#125; onChange=&#123;this.handleChange&#125;/&gt;</span><br><span class="line">        &lt;input type=&#x27;checkbox&#x27; name=&#x27;checkbox&#x27; value=&#123;this.state.checkbox&#125; onChange=&#123;this.handleChange&#125;/&gt;</span><br><span class="line">        &lt;input type=&#x27;textarea&#x27; name=&#x27;textarea&#x27; value=&#123;this.state.textarea&#125; onChange=&#123;this.handleChange&#125;/&gt;</span><br><span class="line">        &lt;select value=&#123;this.state.city&#125; name=&#x27;city&#x27; onChange=&#123;this.handleChange&#125; &gt;</span><br><span class="line">          &lt;option value=&quot;bj&quot;&gt;北京&lt;/option&gt;</span><br><span class="line">          &lt;option value=&quot;sh&quot;&gt;上海&lt;/option&gt;</span><br><span class="line">          &lt;option value=&quot;sz&quot;&gt;深圳&lt;/option&gt;</span><br><span class="line">          &lt;option value=&quot;xa&quot;&gt;西安&lt;/option&gt;</span><br><span class="line">        &lt;/select&gt;</span><br><span class="line"></span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(&lt;App /&gt;, document.getElementById(&#x27;root&#x27;));</span><br></pre></td></tr></table></figure>

<p>效果展示：</p>
<img src="https://489m41372l.vicp.fun/blog/github/21.png" alt="image-20240813094618176" style="zoom:25%;" />

<h4 id="非受控组件（Ref）"><a href="#非受控组件（Ref）" class="headerlink" title="非受控组件（Ref）"></a>非受控组件（Ref）</h4><p>使用ref使用原生DOM方式来获取表单元素值，ref作用：获取DOM或组件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import ReactDOM from &#x27;react-dom&#x27;;</span><br><span class="line">class App extends React.Component &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    super();</span><br><span class="line">   this.txtRef = React.createRef();</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input type=&quot;text&quot; ref=&#123;this.txtRef&#125; /&gt;</span><br><span class="line">        &lt;button onClick=&#123;() =&gt; &#123;</span><br><span class="line">          console.log(this.txtRef.current.value);</span><br><span class="line">        &#125;&#125;&gt;点击按钮&lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(&lt;App /&gt;, document.getElementById(&#x27;root&#x27;));</span><br></pre></td></tr></table></figure>

<h3 id="React-组件案例"><a href="#React-组件案例" class="headerlink" title="React 组件案例"></a>React 组件案例</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React from &#x27;react&#x27;</span><br><span class="line">import ReactDOM from &#x27;react-dom&#x27;</span><br><span class="line">/* </span><br><span class="line">  评论列表案例</span><br><span class="line"></span><br><span class="line">  comments: [</span><br><span class="line">    &#123; id: 1, name: &#x27;jack&#x27;, content: &#x27;沙发！！！&#x27; &#125;,</span><br><span class="line">    &#123; id: 2, name: &#x27;rose&#x27;, content: &#x27;板凳~&#x27; &#125;,</span><br><span class="line">    &#123; id: 3, name: &#x27;tom&#x27;, content: &#x27;楼主好人&#x27; &#125;</span><br><span class="line">  ]</span><br><span class="line">*/</span><br><span class="line">import &#x27;./css/index.css&#x27;</span><br><span class="line">class App extends React.Component &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    name:&#x27;&#x27;,</span><br><span class="line">    content:&#x27;&#x27;,</span><br><span class="line">    comments: []</span><br><span class="line">  &#125;</span><br><span class="line">  //获取受控组件值</span><br><span class="line">  handleChange=(e)=&gt;&#123;</span><br><span class="line">    const target = e.target;</span><br><span class="line">    const value = target.type === &#x27;checkbox&#x27; ? target.checked : target.value;</span><br><span class="line">    const name = target.name;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      [name]: value,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  //渲染评论列表</span><br><span class="line">  renderComments = () =&gt; &#123;</span><br><span class="line">    const &#123; comments &#125; = this.state</span><br><span class="line">    return comments.length === 0 </span><br><span class="line">    ?(&lt;div className=&quot;no-comment&quot;&gt;暂无评论，快去评论吧~&lt;/div&gt;)</span><br><span class="line">    :&lt;div&gt;</span><br><span class="line">      &lt;ul &gt;</span><br><span class="line">        &#123;comments.map(item =&gt; </span><br><span class="line">        &lt;li key=&#123;item.id&#125;&gt;</span><br><span class="line">          &lt;h3&gt;评论人：&#123;item.name&#125;&lt;/h3&gt;     </span><br><span class="line">          &lt;p&gt;&#123;item.content&#125;&lt;/p&gt;</span><br><span class="line">          &lt;/li&gt;)&#125;</span><br><span class="line">      &lt;/ul&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">  //添加评论</span><br><span class="line">  addContent= () =&gt; &#123;</span><br><span class="line">    const &#123; name, content,comments &#125; = this.state</span><br><span class="line">    if(!name.trim() || !content.trim())&#123;</span><br><span class="line">      alert(&#x27;请输入评论人或内容&#x27;)</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    const newComments = [</span><br><span class="line">      &#123;</span><br><span class="line">        id: Math.random(),</span><br><span class="line">        name,</span><br><span class="line">        content</span><br><span class="line">      &#125;,...comments]</span><br><span class="line">      this.setState(&#123;</span><br><span class="line">        comments: newComments,</span><br><span class="line">        name:&#x27;&#x27;,</span><br><span class="line">        content:&#x27;&#x27;</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    const &#123; name, content &#125; = this.state</span><br><span class="line">    return (</span><br><span class="line">      &lt;div className=&quot;app&quot;&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;input className=&quot;user&quot; type=&quot;text&quot; name=&#x27;name&#x27; value=&#123;name&#125; placeholder=&quot;请输入评论人&quot; onChange=&#123;this.handleChange&#125;/&gt;</span><br><span class="line">          &lt;br /&gt;</span><br><span class="line">          &lt;textarea</span><br><span class="line">            className=&quot;content&quot;</span><br><span class="line">            cols=&quot;30&quot;</span><br><span class="line">            rows=&quot;10&quot;</span><br><span class="line">            placeholder=&quot;请输入评论内容&quot;</span><br><span class="line">            name=&quot;content&quot;</span><br><span class="line">            value=&#123;content&#125;</span><br><span class="line">            onChange=&#123;this.handleChange&#125;</span><br><span class="line">          /&gt;</span><br><span class="line">          &lt;br /&gt;</span><br><span class="line">          &lt;button onClick=&#123;this.addContent&#125;&gt;发表评论&lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &#123;</span><br><span class="line">          this.renderComments()</span><br><span class="line">        &#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 渲染组件</span><br><span class="line">ReactDOM.render(&lt;App /&gt;, document.getElementById(&#x27;root&#x27;))</span><br></pre></td></tr></table></figure>

<p>index.css</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.app</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#999</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="selector-class">.user</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: <span class="number">10px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="selector-class">.content</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: <span class="number">10px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="selector-class">.no-comment</span> &#123;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">30px</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<h2 id="React组件通讯"><a href="#React组件通讯" class="headerlink" title="React组件通讯"></a>React组件通讯</h2><p>​	在React中，组件通讯是指不同的组件之间共享数据或相互协作的方式。因为React是基于组件构建用户界面的，每个组件通常会有自己独立的状态和逻辑，但有时候需要让多个组件之间互通信息或共享状态。组件通讯的方式主要取决于组件的层级关系和数据的流向。</p>
<h3 id="组件的props"><a href="#组件的props" class="headerlink" title="组件的props"></a>组件的props</h3><p>props作用：接收传递给组件的数据。只能读取不能修改</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React from &#x27;react&#x27;</span><br><span class="line">import ReactDOM from &#x27;react-dom&#x27;</span><br><span class="line">class App extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    props.fn();</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt; name:&#123;this.props.name&#125;,age:&#123;this.props.age&#125;&lt;/h1&gt;</span><br><span class="line">        &#123;this.props.tag&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 渲染组件</span><br><span class="line">ReactDOM.render(&lt;App</span><br><span class="line">   name=&quot;张三&quot; age=&quot;18&quot; colors=&#123;[&#x27;red&#x27;,&#x27;green&#x27;,&#x27;blue&#x27;]&#125; </span><br><span class="line">   fn=&#123;()=&gt; console.log(&quot;我是一个函数&quot;)&#125;</span><br><span class="line">   tag=&#123;&lt;p&gt;这是一个组件&lt;/p&gt;&#125;</span><br><span class="line">   /&gt;, </span><br><span class="line">   document.getElementById(&#x27;root&#x27;))</span><br></pre></td></tr></table></figure>

<h3 id="组件通讯的三种方式"><a href="#组件通讯的三种方式" class="headerlink" title="组件通讯的三种方式"></a>组件通讯的三种方式</h3><h4 id="父子通讯"><a href="#父子通讯" class="headerlink" title="父子通讯"></a>父子通讯</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React from &#x27;react&#x27;</span><br><span class="line">import ReactDOM from &#x27;react-dom&#x27;</span><br><span class="line">import &#x27;./css/index.css&#x27;</span><br><span class="line">// 父组件</span><br><span class="line">class Parent extends React.Component &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    name: &#x27;张三&#x27;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div className=&quot;parent&quot;&gt;</span><br><span class="line">        父组件：</span><br><span class="line">        &lt;Child  name=&#123;this.state.name&#125;/&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 子组件</span><br><span class="line">const Child = (props) =&gt; &#123;</span><br><span class="line">  const name = props.name</span><br><span class="line">  return (</span><br><span class="line">    &lt;div className=&quot;child&quot;&gt;</span><br><span class="line">      &lt;p&gt;子组件，接收到父组件的数据：&#123;name&#125;&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(&lt;Parent /&gt;, document.getElementById(&#x27;root&#x27;))</span><br></pre></td></tr></table></figure>

<p>index.css</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: skyblue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: aquamarine;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="子到父通讯"><a href="#子到父通讯" class="headerlink" title="子到父通讯"></a>子到父通讯</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React from &#x27;react&#x27;</span><br><span class="line">import ReactDOM from &#x27;react-dom&#x27;</span><br><span class="line">import &#x27;./css/index.css&#x27;</span><br><span class="line">// 父组件</span><br><span class="line">class Parent extends React.Component &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    parentMsg: &#x27;&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">  // 提供回调函数，用来接收数据</span><br><span class="line">  getChildMsg = data =&gt; &#123;</span><br><span class="line">    console.log(&#x27;接收到子组件中传递过来的数据：&#x27;, data)</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      parentMsg: data</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div className=&quot;parent&quot;&gt;</span><br><span class="line">        父组件：&#123;this.state.parentMsg&#125;</span><br><span class="line">        &lt;Child getMsg=&#123;this.getChildMsg&#125; /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 子组件</span><br><span class="line">class Child extends React.Component &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    msg: &#x27;刷知乎&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">  handleClick = () =&gt; &#123;</span><br><span class="line">    this.props.getMsg(this.state.msg)</span><br><span class="line">  &#125;</span><br><span class="line">  render()&#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div className=&quot;child&quot;&gt;</span><br><span class="line">        子组件：&#123;&#x27; &#x27;&#125;</span><br><span class="line">        &lt;button onClick=&#123;this.handleClick&#125;&gt;点我，给父组件传递数据&lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(&lt;Parent /&gt;, document.getElementById(&#x27;root&#x27;))</span><br></pre></td></tr></table></figure>

<h4 id="兄弟组件通讯"><a href="#兄弟组件通讯" class="headerlink" title="兄弟组件通讯"></a>兄弟组件通讯</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React from &#x27;react&#x27;</span><br><span class="line">import ReactDOM from &#x27;react-dom&#x27;</span><br><span class="line">// 父组件</span><br><span class="line">class Parent extends React.Component &#123;</span><br><span class="line">//共享数据</span><br><span class="line">  state = &#123;</span><br><span class="line">    count:0,</span><br><span class="line">  &#125;</span><br><span class="line">  // 提供回调函数，用来接收数据</span><br><span class="line">  onIncrement=()=&gt;&#123;</span><br><span class="line">    this.setState(&#123;count: this.state.count + 1&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Child1  count=&#123;this.state.count&#125;/&gt;</span><br><span class="line">        &lt;Child2 onIncrement=&#123;this.onIncrement&#125; /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//子组件</span><br><span class="line">const Child1 = props =&gt; &lt;h1&gt;计数器：&#123;props.count&#125;&lt;/h1&gt;</span><br><span class="line">const Child2 = props =&gt; &lt;button onClick=&#123;()=&gt;props.onIncrement()&#125;&gt;+1&lt;/button&gt;</span><br><span class="line">ReactDOM.render(&lt;Parent /&gt;, document.getElementById(&#x27;root&#x27;))</span><br></pre></td></tr></table></figure>

<h3 id="Context的使用"><a href="#Context的使用" class="headerlink" title="Context的使用"></a>Context的使用</h3><p>使用上面的通讯方法，层级过多以后就会很繁琐，我们使用Contet进行跨组件传递数据(语言等)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import ReactDOM from &#x27;react-dom&#x27;;</span><br><span class="line">import &#x27;./css/index.css&#x27;;</span><br><span class="line"></span><br><span class="line">const &#123; Provider, Consumer &#125; = React.createContext();</span><br><span class="line"></span><br><span class="line">class App extends React.Component &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    songs: &#123;</span><br><span class="line">      name: &#x27;zhangsan&#x27;,</span><br><span class="line">      age: 18</span><br><span class="line">    &#125;,</span><br><span class="line">    logMessage: () =&gt; &#123;</span><br><span class="line">      console.log(&#x27;This is a message from Context!&#x27;);</span><br><span class="line">    &#125;,</span><br><span class="line">    CustomComponent: () =&gt; &lt;div style=&#123;&#123; backgroundColor: &#x27;lightblue&#x27;&#125;&#125;&gt;我是一个来自 Context 的自定义组件&lt;/div&gt;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;Provider value=&#123;this.state&#125;&gt;</span><br><span class="line">        &lt;div className=&quot;app&quot;&gt;</span><br><span class="line">          &lt;Node /&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/Provider&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const Node = () =&gt; &lt;div className=&quot;node&quot;&gt;&lt;SubNode /&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">const SubNode = () =&gt; &lt;div className=&quot;subnode&quot;&gt;&lt;Child /&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">const Child = () =&gt; &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div className=&quot;child&quot;&gt;</span><br><span class="line">      &lt;Consumer&gt;</span><br><span class="line">        &#123;context =&gt; (</span><br><span class="line">          &lt;div&gt;</span><br><span class="line">            &lt;span&gt;我是子节点 -- 名字: &#123;context.songs.name&#125;, 年龄: &#123;context.songs.age&#125;&lt;/span&gt;</span><br><span class="line">            &lt;button onClick=&#123;context.logMessage&#125;&gt;点击我执行函数&lt;/button&gt;</span><br><span class="line">            &lt;context.CustomComponent /&gt;</span><br><span class="line">          &lt;/div&gt;</span><br><span class="line">        )&#125;</span><br><span class="line">      &lt;/Consumer&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;App /&gt;, document.getElementById(&#x27;root&#x27;));</span><br></pre></td></tr></table></figure>

<h3 id="children属性"><a href="#children属性" class="headerlink" title="children属性"></a>children属性</h3><ul>
<li>children属性只有当组件有子节点时，props才会有该属性</li>
<li>children属性与普通props一样，值可以是任意值（文本，组件，React元素，函数方法）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import ReactDOM from &#x27;react-dom&#x27;;</span><br><span class="line"></span><br><span class="line">const App = props =&gt;&#123;</span><br><span class="line">  props.children()</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;Hello World&lt;/h1&gt;</span><br><span class="line">      &lt;p&gt;&#123;props.children&#125;&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;App&gt;&#123;()=&gt;&#123;</span><br><span class="line">  console.log(&quot;子节点children&quot;)</span><br><span class="line">&#125;&#125;&lt;/App&gt;, document.getElementById(&#x27;root&#x27;));</span><br></pre></td></tr></table></figure>

<h3 id="props校验"><a href="#props校验" class="headerlink" title="props校验"></a>props校验</h3><p>作用：保证组件使用者传入的类型、格式限制，给出错误提示，增加代码健壮性</p>
<ol>
<li>安装包 prop-types(yarn add prop-types&#x2F;npmiprops-types )</li>
<li>引入<code>import PropTypes from &#39;prop-types&#39;;</code>文件</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import ReactDOM from &#x27;react-dom&#x27;;</span><br><span class="line">import PropTypes from &#x27;prop-types&#x27;;</span><br><span class="line"></span><br><span class="line">const App = props =&gt;&#123;</span><br><span class="line">  const arr = props.colors;</span><br><span class="line">  const list = arr.map(item =&gt; &lt;li key=&#123;item&#125;&gt;&#123;item&#125;&lt;/li&gt;);</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;ul&gt;&#123;list&#125;&lt;/ul&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 基本数据类型</span><br><span class="line">PropTypes.string: 检查 prop 是否为字符串类型。</span><br><span class="line">PropTypes.number: 检查 prop 是否为数字类型。</span><br><span class="line">PropTypes.boolean: 检查 prop 是否为布尔类型。</span><br><span class="line">PropTypes.object: 检查 prop 是否为对象类型。</span><br><span class="line">PropTypes.array: 检查 prop 是否为数组类型。</span><br><span class="line">PropTypes.func: 检查 prop 是否为函数类型。</span><br><span class="line">PropTypes.symbol: 检查 prop 是否为 symbol 类型。</span><br><span class="line">PropTypes.node: 检查 prop 是否为任何可以被渲染的内容（字符串、数字、元素或数组等）。</span><br><span class="line">PropTypes.element: 检查 prop 是否为 React 元素。</span><br><span class="line">特殊类型</span><br><span class="line">PropTypes.any: 可以是任意类型。</span><br><span class="line">PropTypes.isRequired: 标记一个 prop 为必填项。</span><br><span class="line">PropTypes.instanceOf(Class): 检查 prop 是否为指定类的实例。</span><br><span class="line">PropTypes.oneOf([&#x27;Option1&#x27;, &#x27;Option2&#x27;]): 检查 prop 是否为给定值列表中的一个值（枚举）。</span><br><span class="line">PropTypes.oneOfType([PropTypes.string, PropTypes.number]): 检查 prop 是否为给定类型列表中的一个。</span><br><span class="line">PropTypes.arrayOf(PropTypes.string): 检查 prop 是否为特定类型的数组。</span><br><span class="line">PropTypes.objectOf(PropTypes.string): 检查 prop 是否为特定类型值的对象。</span><br><span class="line">PropTypes.shape(&#123; key: PropTypes.string, value: PropTypes.number &#125;): 检查 prop 是否为具有指定键值对的对象。</span><br><span class="line">PropTypes.exact(&#123; key1: PropTypes.string, key2: PropTypes.number &#125;): 检查 prop 是否为具有指定键值对且没有其他多余键的对象。</span><br><span class="line"> */</span><br><span class="line">App.propTypes = &#123;</span><br><span class="line">  colors: PropTypes.array,</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(&lt;App colors=&#123;[1,2,3,4]&#125;/&gt;, document.getElementById(&#x27;root&#x27;));</span><br></pre></td></tr></table></figure>

<p>具体类型可以查看<a href="https://zh-hans.legacy.reactjs.org/docs/typechecking-with-proptypes.html">React propsType 校验规则</a></p>
<h3 id="props默认值"><a href="#props默认值" class="headerlink" title="props默认值"></a>props默认值</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import ReactDOM from &#x27;react-dom&#x27;;</span><br><span class="line">const App = props =&gt;&#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      props默认值：&#123;props.number&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line">App.defaultProps = &#123;</span><br><span class="line">  number:10,</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(&lt;App/&gt;, document.getElementById(&#x27;root&#x27;));</span><br></pre></td></tr></table></figure>

<h2 id="React组件的生命周期"><a href="#React组件的生命周期" class="headerlink" title="React组件的生命周期"></a>React组件的生命周期</h2><p><strong>只有类组件才有生命周期</strong></p>
<p><img src="https://489m41372l.vicp.fun/blog/github/22.png" alt="image-20240813144907167"></p>
<h4 id="创建时（挂载阶段）"><a href="#创建时（挂载阶段）" class="headerlink" title="创建时（挂载阶段）"></a>创建时（挂载阶段）</h4><p>执行时机：页面加载时</p>
<p>执行顺序：<img src="https://489m41372l.vicp.fun/blog/github/23.png" alt="image-20240813145342586"></p>
<table>
<thead>
<tr>
<th align="center">钩子函数</th>
<th align="center">触发时机</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">constructor</td>
<td align="center">创建组件时，最先执行</td>
<td>初始化state <br/>为函数方法绑定this</td>
</tr>
<tr>
<td align="center">render</td>
<td align="center">每次组件渲染都会触发</td>
<td>渲染UI（**不能调用setState()**）</td>
</tr>
<tr>
<td align="center">componentDidMount</td>
<td align="center">组件挂载完（完成DOM渲染后）</td>
<td>发送网络请求<br>DOM操作</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import ReactDOM from &#x27;react-dom&#x27;;</span><br><span class="line">class App extends React.Component &#123;</span><br><span class="line">  constructor(props)&#123;</span><br><span class="line">    super(props);</span><br><span class="line">    console.warn(&#x27;constructor钩子执行了&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidMount()&#123;</span><br><span class="line">    console.warn(&#x27;componentDidMount钩子执行了&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    console.warn(&#x27;render钩子执行了&#x27;);</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;Hello, world!&lt;/h1&gt;</span><br><span class="line">        &lt;button id=&quot;btn&quot;&gt;点我&lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(&lt;App/&gt;, document.getElementById(&#x27;root&#x27;));</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>结果：</p>
<img src="https://489m41372l.vicp.fun/blog/github/24.png" alt="image-20240813150720219" style="zoom: 50%;" />

<h4 id="更新时"><a href="#更新时" class="headerlink" title="更新时"></a>更新时</h4><p>执行顺序：</p>
<p><img src="https://489m41372l.vicp.fun/blog/github/25.png" alt="image-20240814095139815"></p>
<p>render钩子执行时机：</p>
<ol>
<li><p>setState（）</p>
</li>
<li><p>forceUpdate()</p>
</li>
<li><p>组件接收到新的props</p>
<p>任意一种都会导致render钩子执行</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React from &#x27;react&#x27;</span><br><span class="line">import ReactDOM from &#x27;react-dom&#x27;</span><br><span class="line"></span><br><span class="line">/* </span><br><span class="line">  组件生命周期</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">class App extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props)</span><br><span class="line"></span><br><span class="line">    // 初始化state</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      count: 0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 打豆豆</span><br><span class="line">  handleClick = () =&gt; &#123;</span><br><span class="line">    // this.setState(&#123;</span><br><span class="line">    //   count: this.state.count + 1</span><br><span class="line">    // &#125;)</span><br><span class="line"></span><br><span class="line">    // 演示强制更新：</span><br><span class="line">    this.forceUpdate()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    console.warn(&#x27;生命周期钩子函数： render&#x27;)</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Counter count=&#123;this.state.count&#125; /&gt;</span><br><span class="line">        &lt;button onClick=&#123;this.handleClick&#125;&gt;打豆豆&lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Counter extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    console.warn(&#x27;--子组件--生命周期钩子函数： render&#x27;)</span><br><span class="line">    return &lt;h1&gt;统计豆豆被打的次数：&#123;this.props.count&#125;&lt;/h1&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;App /&gt;, document.getElementById(&#x27;root&#x27;))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">钩子函数</th>
<th align="center">触发时机</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">render</td>
<td align="center">每次组件渲染都会触发</td>
<td align="center">渲染UI</td>
</tr>
<tr>
<td align="center">componentDidUpdate</td>
<td align="center">组件更新（完成DOM渲染后）</td>
<td align="center">发送网络请求<br>DOM操作（setState()必须放在一个if条件中）</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React from &#x27;react&#x27;</span><br><span class="line">import ReactDOM from &#x27;react-dom&#x27;</span><br><span class="line"></span><br><span class="line">/* </span><br><span class="line">  组件生命周期</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">class App extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props)</span><br><span class="line"></span><br><span class="line">    // 初始化state</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      count: 0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 打豆豆</span><br><span class="line">  handleClick = () =&gt; &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      count: this.state.count + 1</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Counter count=&#123;this.state.count&#125; /&gt;</span><br><span class="line">        &lt;button onClick=&#123;this.handleClick&#125;&gt;打豆豆&lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Counter extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    console.warn(&#x27;--子组件--生命周期钩子函数： render&#x27;)</span><br><span class="line">    return &lt;h1 id=&quot;title&quot;&gt;统计豆豆被打的次数：&#123;this.props.count&#125;&lt;/h1&gt;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 注意：如果要调用 setState() 更新状态，必须要放在一个 if 条件中</span><br><span class="line">  // 因为：如果直接调用 setState() 更新状态，也会导致递归更新！！！</span><br><span class="line">  componentDidUpdate(prevProps) &#123;</span><br><span class="line">    console.warn(&#x27;--子组件--生命周期钩子函数： componentDidUpdate&#x27;)</span><br><span class="line"></span><br><span class="line">    // 正确做法：</span><br><span class="line">    // 做法：比较更新前后的props是否相同，来决定是否重新渲染组件</span><br><span class="line">    console.log(&#x27;上一次的props：&#x27;, prevProps, &#x27;, 当前的props：&#x27;, this.props)</span><br><span class="line">    if (prevProps.count !== this.props.count) &#123;</span><br><span class="line">      // this.setState(&#123;&#125;)</span><br><span class="line">      // 发送ajax请求的代码</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 错误演示！！！</span><br><span class="line">    // this.setState(&#123;&#125;)</span><br><span class="line"></span><br><span class="line">    // 获取DOM</span><br><span class="line">    // const title = document.getElementById(&#x27;title&#x27;)</span><br><span class="line">    // console.log(title.innerHTML)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;App /&gt;, document.getElementById(&#x27;root&#x27;))</span><br></pre></td></tr></table></figure>

<h4 id="卸载时"><a href="#卸载时" class="headerlink" title="卸载时"></a>卸载时</h4><p>执行时机：组件从页面消失</p>
<table>
<thead>
<tr>
<th align="center">钩子函数</th>
<th align="center">触发时机</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">componentWillUnmount</td>
<td align="center">卸载组件</td>
<td align="center">执行清理工作(比如：清除定时器等)</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React from &#x27;react&#x27;</span><br><span class="line">import ReactDOM from &#x27;react-dom&#x27;</span><br><span class="line"></span><br><span class="line">/* </span><br><span class="line">  组件生命周期</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">class App extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props)</span><br><span class="line"></span><br><span class="line">    // 初始化state</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      count: 0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 打豆豆</span><br><span class="line">  handleClick = () =&gt; &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      count: this.state.count + 1</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;this.state.count &gt; 3 ? (</span><br><span class="line">          &lt;p&gt;豆豆被打死了~&lt;/p&gt;</span><br><span class="line">        ) : (</span><br><span class="line">          &lt;Counter count=&#123;this.state.count&#125; /&gt;</span><br><span class="line">        )&#125;</span><br><span class="line">        &lt;button onClick=&#123;this.handleClick&#125;&gt;打豆豆&lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Counter extends React.Component &#123;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    // 开启定时器</span><br><span class="line">    this.timerId = setInterval(() =&gt; &#123;</span><br><span class="line">      console.log(&#x27;定时器正在执行~&#x27;)</span><br><span class="line">    &#125;, 500)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;h1&gt;统计豆豆被打的次数：&#123;this.props.count&#125;&lt;/h1&gt;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    console.warn(&#x27;生命周期钩子函数： componentWillUnmount&#x27;)</span><br><span class="line"></span><br><span class="line">    // 清理定时器</span><br><span class="line">    clearInterval(this.timerId)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;App /&gt;, document.getElementById(&#x27;root&#x27;))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="React组件复用案例"><a href="#React组件复用案例" class="headerlink" title="React组件复用案例"></a>React组件复用案例</h2><h4 id="props-render-模式"><a href="#props-render-模式" class="headerlink" title="props render 模式"></a>props render 模式</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React from &#x27;react&#x27;</span><br><span class="line">import ReactDOM from &#x27;react-dom&#x27;</span><br><span class="line">import img from &#x27;./images/cat.png&#x27;</span><br><span class="line">/* </span><br><span class="line">  render props 模式</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">// 创建Mouse组件</span><br><span class="line">class Mouse extends React.Component &#123;</span><br><span class="line">  // 鼠标位置state</span><br><span class="line">  state = &#123;</span><br><span class="line">    x: 0,</span><br><span class="line">    y: 0</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 鼠标移动事件的事件处理程序</span><br><span class="line">  handleMouseMove = e =&gt; &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      x: e.clientX,</span><br><span class="line">      y: e.clientY</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 监听鼠标移动事件</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    window.addEventListener(&#x27;mousemove&#x27;, this.handleMouseMove)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    // return null</span><br><span class="line">    return this.props.render(this.state)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class App extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;render props 模式&lt;/h1&gt;</span><br><span class="line">        &lt;Mouse</span><br><span class="line">          render=&#123;mouse =&gt; &#123;</span><br><span class="line">            return (</span><br><span class="line">              &lt;img  src=&#123;img&#125; alt=&#x27;猫&#x27; style=&#123;&#123;</span><br><span class="line">                position: &#x27;absolute&#x27;,</span><br><span class="line">                left: mouse.x-64,</span><br><span class="line">                top: mouse.y-64</span><br><span class="line">              &#125;&#125;/&gt;</span><br><span class="line">            )</span><br><span class="line">          &#125;&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;App /&gt;, document.getElementById(&#x27;root&#x27;))</span><br></pre></td></tr></table></figure>

<h4 id="props-children模式"><a href="#props-children模式" class="headerlink" title="props children模式"></a>props children模式</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React from &#x27;react&#x27;</span><br><span class="line">import ReactDOM from &#x27;react-dom&#x27;</span><br><span class="line">import img from &#x27;./images/cat.png&#x27;</span><br><span class="line">import propTypes from &#x27;prop-types&#x27;</span><br><span class="line">/* </span><br><span class="line">  render props 模式</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">// 创建Mouse组件</span><br><span class="line">class Mouse extends React.Component &#123;</span><br><span class="line">  // 鼠标位置state</span><br><span class="line">  state = &#123;</span><br><span class="line">    x: 0,</span><br><span class="line">    y: 0</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 鼠标移动事件的事件处理程序</span><br><span class="line">  handleMouseMove = e =&gt; &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      x: e.clientX,</span><br><span class="line">      y: e.clientY</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 监听鼠标移动事件</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    window.addEventListener(&#x27;mousemove&#x27;, this.handleMouseMove)</span><br><span class="line">  &#125;</span><br><span class="line">  // 移除监听事件</span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    window.removeEventListener(&#x27;mousemove&#x27;, this.handleMouseMove)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">     return this.props.children(this.state)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//对children进行类型检查</span><br><span class="line">Mouse.propTypes=&#123;</span><br><span class="line">  children: propTypes.func.isRequired</span><br><span class="line">&#125;</span><br><span class="line">class App extends React.Component &#123;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;Mouse &gt;</span><br><span class="line">         &#123;mouse =&gt; &#123;</span><br><span class="line">            return (</span><br><span class="line">              &lt;img  src=&#123;img&#125; alt=&#x27;猫&#x27; style=&#123;&#123;</span><br><span class="line">                position: &#x27;absolute&#x27;,</span><br><span class="line">                left: mouse.x-64,</span><br><span class="line">                top: mouse.y-64</span><br><span class="line">              &#125;&#125; /&gt;</span><br><span class="line">            )</span><br><span class="line">          &#125;&#125;&lt;/Mouse&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(&lt;App /&gt;, document.getElementById(&#x27;root&#x27;))</span><br></pre></td></tr></table></figure>

<h4 id="高阶组件复用"><a href="#高阶组件复用" class="headerlink" title="高阶组件复用"></a>高阶组件复用</h4><ol>
<li>创建一个函数，名称为with开头</li>
<li>指定函数参数，参数以大写字母开头（为要渲染的组件）</li>
<li>在函数中创建一个类组件，提供复用的代码，并返回</li>
<li>在该组件中渲染参数组件，同时将状态通过props传递给参数组件</li>
<li>调用高阶组件，传入要增强的组件，通过返回值拿到增强后组件，将其返回页面</li>
<li>设置displayName解决多个使用增强后组件的 名称重复问题</li>
<li>将props也传递给增强组件</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React from &#x27;react&#x27;</span><br><span class="line">import ReactDOM from &#x27;react-dom&#x27;</span><br><span class="line"></span><br><span class="line">/* </span><br><span class="line">  高阶组件</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">// 创建高阶组件</span><br><span class="line">function withMouse(WrappedComponent) &#123;</span><br><span class="line">  // 该组件提供复用的状态逻辑</span><br><span class="line">  class Mouse extends React.Component &#123;</span><br><span class="line">    // 鼠标状态</span><br><span class="line">    state = &#123;</span><br><span class="line">      x: 0,</span><br><span class="line">      y: 0</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handleMouseMove = e =&gt; &#123;</span><br><span class="line">      this.setState(&#123;</span><br><span class="line">        x: e.clientX,</span><br><span class="line">        y: e.clientY</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 控制鼠标状态的逻辑</span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">      window.addEventListener(&#x27;mousemove&#x27;, this.handleMouseMove)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    componentWillUnmount() &#123;</span><br><span class="line">      window.removeEventListener(&#x27;mousemove&#x27;, this.handleMouseMove)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">      console.log(&#x27;Mouse:&#x27;, this.props)</span><br><span class="line">      return &lt;WrappedComponent &#123;...this.state&#125; &#123;...this.props&#125; /&gt;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 设置displayName</span><br><span class="line">  Mouse.displayName = `WithMouse$&#123;getDisplayName(WrappedComponent)&#125;`</span><br><span class="line">  return Mouse</span><br><span class="line">&#125;</span><br><span class="line">// 返回增强后组件的名称</span><br><span class="line">function getDisplayName(WrappedComponent) &#123;</span><br><span class="line">  return WrappedComponent.displayName || WrappedComponent.name || &#x27;Component&#x27;</span><br><span class="line">&#125;</span><br><span class="line">// 用来测试高阶组件</span><br><span class="line">const Position = props =&gt; &#123;</span><br><span class="line">  console.log(&#x27;Position:&#x27;, props)</span><br><span class="line">  return (</span><br><span class="line">    &lt;p&gt;</span><br><span class="line">      鼠标当前位置：(x: &#123;props.x&#125;, y: &#123;props.y&#125;)</span><br><span class="line">    &lt;/p&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取增强后的组件：</span><br><span class="line">const MousePosition = withMouse(Position)</span><br><span class="line">class App extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;高阶组件&lt;/h1&gt;</span><br><span class="line">        &lt;MousePosition q=&quot;q&quot; /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(&lt;App /&gt;, document.getElementById(&#x27;root&#x27;))</span><br></pre></td></tr></table></figure>

<h2 id="优化代码写法"><a href="#优化代码写法" class="headerlink" title="优化代码写法"></a>优化代码写法</h2><h3 id="setState-优化"><a href="#setState-优化" class="headerlink" title="setState()优化"></a>setState()优化</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React from &#x27;react&#x27;</span><br><span class="line">import ReactDOM from &#x27;react-dom&#x27;</span><br><span class="line"></span><br><span class="line">/* </span><br><span class="line">  setState() 异步更新数据</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">class App extends React.Component &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    count: 1</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick = () =&gt; &#123;</span><br><span class="line">    // 此处，更新state</span><br><span class="line">    // 注意：异步更新数据的！！！</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      count: this.state.count + 1</span><br><span class="line">    &#125;)</span><br><span class="line">    console.log(&#x27;count：&#x27;, this.state.count) // 1</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      count: this.state.count + 1 // 1 + 1</span><br><span class="line">    &#125;)</span><br><span class="line">    console.log(&#x27;count：&#x27;, this.state.count) // 1</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    console.log(&#x27;render&#x27;)</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;计数器：&#123;this.state.count&#125;&lt;/h1&gt;</span><br><span class="line">        &lt;button onClick=&#123;this.handleClick&#125;&gt;+1&lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;App /&gt;, document.getElementById(&#x27;root&#x27;))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>由于setState()方法是异步执行的导致我们不能立即拿到更新后的状态所以我们要优化下setstate()方法从而拿到最新的状态代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React from &#x27;react&#x27;</span><br><span class="line">import ReactDOM from &#x27;react-dom&#x27;</span><br><span class="line"></span><br><span class="line">class App extends React.Component &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    count: 1</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick = () =&gt; &#123;</span><br><span class="line">    this.setState((state, props) =&gt; &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        count: state.count + 1 </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, () =&gt; &#123;</span><br><span class="line">      console.log(&#x27;第一次更新后:&#x27;, this.state.count); // 2</span><br><span class="line">      this.setState((state, props) =&gt; &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">          count: state.count + 1</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, () =&gt; &#123;</span><br><span class="line">        console.log(&#x27;第二次更新后:&#x27;, this.state.count); // 3</span><br><span class="line">        console.log(document.getElementById(&#x27;title&#x27;).innerText);</span><br><span class="line">        document.title = &#x27;更新后的count为：&#x27; + this.state.count;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    console.log(&#x27;count:&#x27;, this.state.count); // 1，异步更新，因此这里的count依然是1</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1 id=&quot;title&quot;&gt;计数器：&#123;this.state.count&#125;&lt;/h1&gt;</span><br><span class="line">        &lt;button onClick=&#123;this.handleClick&#125;&gt;+1&lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;App /&gt;, document.getElementById(&#x27;root&#x27;))</span><br></pre></td></tr></table></figure>

<h3 id="React组件更新机制"><a href="#React组件更新机制" class="headerlink" title="React组件更新机制"></a>React组件更新机制</h3><p>React更新机制是 只更新当前组件和其子组件其他组件不会更新</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React from &#x27;react&#x27;</span><br><span class="line">import ReactDOM from &#x27;react-dom&#x27;</span><br><span class="line"></span><br><span class="line">/* </span><br><span class="line">  组件更新机制</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">import &#x27;./index.css&#x27;</span><br><span class="line"></span><br><span class="line">// 根组件</span><br><span class="line">class App extends React.Component &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    color: &#x27;#369&#x27;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getColor() &#123;</span><br><span class="line">    return Math.floor(Math.random() * 256)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  changeBG = () =&gt; &#123;</span><br><span class="line">    this.setState(() =&gt; &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        color: `rgb($&#123;this.getColor()&#125;, $&#123;this.getColor()&#125;, $&#123;this.getColor()&#125;)`</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    console.log(&#x27;根组件&#x27;)</span><br><span class="line">    return (</span><br><span class="line">      &lt;div className=&quot;app&quot; style=&#123;&#123; backgroundColor: this.state.color &#125;&#125;&gt;</span><br><span class="line">        &lt;button onClick=&#123;this.changeBG&#125;&gt;根组件 - 切换颜色状态&lt;/button&gt;</span><br><span class="line">        &lt;div className=&quot;app-wrapper&quot;&gt;</span><br><span class="line">          &lt;Parent1 /&gt;</span><br><span class="line">          &lt;Parent2 /&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ------------------------左侧---------------------------</span><br><span class="line"></span><br><span class="line">class Parent1 extends React.Component &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    count: 0</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick = () =&gt; &#123;</span><br><span class="line">    this.setState(state =&gt; (&#123; count: state.count + 1 &#125;))</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    console.log(&#x27;左侧父组件&#x27;)</span><br><span class="line">    return (</span><br><span class="line">      &lt;div className=&quot;parent&quot;&gt;</span><br><span class="line">        &lt;h2&gt;</span><br><span class="line">          左侧 - 父组件1</span><br><span class="line">          &lt;button onClick=&#123;this.handleClick&#125;&gt;点我（&#123;this.state.count&#125;）&lt;/button&gt;</span><br><span class="line">        &lt;/h2&gt;</span><br><span class="line">        &lt;div className=&quot;parent-wrapper&quot;&gt;</span><br><span class="line">          &lt;Child1 /&gt;</span><br><span class="line">          &lt;Child2 /&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child1 extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    console.log(&#x27;左侧子组件 - 1&#x27;)</span><br><span class="line">    return &lt;div className=&quot;child&quot;&gt;子组件1-1&lt;/div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Child2 extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    console.log(&#x27;左侧子组件 - 2&#x27;)</span><br><span class="line">    return &lt;div className=&quot;child&quot;&gt;子组件1-2&lt;/div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ------------------------右侧---------------------------</span><br><span class="line"></span><br><span class="line">class Parent2 extends React.Component &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    count: 0</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick = () =&gt; &#123;</span><br><span class="line">    this.setState(state =&gt; (&#123; count: state.count + 1 &#125;))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    console.log(&#x27;右侧父组件&#x27;)</span><br><span class="line">    return (</span><br><span class="line">      &lt;div className=&quot;parent&quot;&gt;</span><br><span class="line">        &lt;h2&gt;</span><br><span class="line">          右侧 - 父组件2</span><br><span class="line">          &lt;button onClick=&#123;this.handleClick&#125;&gt;点我（&#123;this.state.count&#125;）&lt;/button&gt;</span><br><span class="line">        &lt;/h2&gt;</span><br><span class="line">        &lt;div className=&quot;parent-wrapper&quot;&gt;</span><br><span class="line">          &lt;Child3 /&gt;</span><br><span class="line">          &lt;Child4 /&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child3 extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    console.log(&#x27;右侧子组件 - 1&#x27;)</span><br><span class="line">    return &lt;div className=&quot;child&quot;&gt;子组件2-1&lt;/div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Child4 extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    console.log(&#x27;右侧子组件 - 2&#x27;)</span><br><span class="line">    return &lt;div className=&quot;child&quot;&gt;子组件2-2 &lt;/div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(&lt;App /&gt;, document.getElementById(&#x27;root&#x27;))</span><br></pre></td></tr></table></figure>

<h3 id="shouldComponentUpdate"><a href="#shouldComponentUpdate" class="headerlink" title="shouldComponentUpdate"></a>shouldComponentUpdate</h3><p>shouldComponentUpdate(nextProps, nextState){}钩子函数可以让组件进行不必要的更新</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React from &#x27;react&#x27;</span><br><span class="line">import ReactDOM from &#x27;react-dom&#x27;</span><br><span class="line"></span><br><span class="line">/* </span><br><span class="line">  组件性能优化：</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">// 生成随机数</span><br><span class="line">class App extends React.Component &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    number: 0</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick = () =&gt; &#123;</span><br><span class="line">    this.setState(() =&gt; &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        number: Math.floor(Math.random() * 3)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 因为两次生成的随机数可能相同，如果相同，此时，不需要重新渲染</span><br><span class="line">  // shouldComponentUpdate(nextProps, nextState) &#123;</span><br><span class="line">  //   console.log(&#x27;最新状态：&#x27;, nextState, &#x27;, 当前状态：&#x27;, this.state)</span><br><span class="line">  //   return nextState.number !== this.state.number</span><br><span class="line">  // &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    // console.log(&#x27;render&#x27;)</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;NumberBox number=&#123;this.state.number&#125; /&gt;</span><br><span class="line">        &lt;button onClick=&#123;this.handleClick&#125;&gt;重新生成&lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class NumberBox extends React.Component &#123;</span><br><span class="line">  shouldComponentUpdate(nextProps) &#123;</span><br><span class="line">    console.log(&#x27;最新props：&#x27;, nextProps, &#x27;, 当前props：&#x27;, this.props)</span><br><span class="line">    // 如果前后两次的number值相同，就返回false，不更新组件</span><br><span class="line">    return nextProps.number !== this.props.number</span><br><span class="line"></span><br><span class="line">    // if (nextProps.number === this.props.number) &#123;</span><br><span class="line">    //   return false</span><br><span class="line">    // &#125;</span><br><span class="line">    // return true</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    console.log(&#x27;子组件中的render&#x27;)</span><br><span class="line">    return &lt;h1&gt;随机数：&#123;this.props.number&#125;&lt;/h1&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;App /&gt;, document.getElementById(&#x27;root&#x27;))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="React路由"><a href="#React路由" class="headerlink" title="React路由"></a>React路由</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><ol>
<li>安装：<code>yarn add react-router-dom</code></li>
<li>导入路由的三个核心组件 <code>import &#123; BrowserRouter as Router, Routes, Route, Link &#125; from &#39;react-router-dom&#39;;</code></li>
<li>使用<strong>Router</strong>组件包裹整个应用</li>
<li>Link组件 指定路由入口</li>
<li>Route组件指定路由出口</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import ReactDOM from &#x27;react-dom&#x27;;</span><br><span class="line">import &#123; BrowserRouter as Router, Routes, Route, Link &#125; from &#x27;react-router-dom&#x27;;</span><br><span class="line"></span><br><span class="line">const First = () =&gt; &lt;p&gt;页面一的内容&lt;/p&gt;;</span><br><span class="line"></span><br><span class="line">const App = () =&gt; (</span><br><span class="line">  &lt;Router&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;React路由基础&lt;/h1&gt;</span><br><span class="line">      &#123;/* 指定路由入口 */&#125;</span><br><span class="line">      &lt;Link to=&quot;/first&quot;&gt;页面一&lt;/Link&gt;</span><br><span class="line"></span><br><span class="line">      &#123;/* 指定路由出口 */&#125;</span><br><span class="line">      &lt;Routes&gt;</span><br><span class="line">        &#123;/* 点击链接后才显示 First 组件 */&#125;</span><br><span class="line">        &lt;Route path=&quot;/first&quot; element=&#123;&lt;First /&gt;&#125; /&gt;</span><br><span class="line">      &lt;/Routes&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/Router&gt;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;App /&gt;, document.getElementById(&#x27;root&#x27;));</span><br></pre></td></tr></table></figure>

<h3 id="路由的执行过程"><a href="#路由的执行过程" class="headerlink" title="路由的执行过程"></a>路由的执行过程</h3><ol>
<li>点击 Link 组件(a标签)，修改了浏览器地址栏中的 url 。</li>
<li>React 路由监听到地址栏 ur 的变化。</li>
<li>React 路由内部遍历所有 Route 组件，使用路由规则( path)与 pathname 进行匹配。</li>
<li>当路由规则(path)能够匹配地址栏中的pathname 时，就展示该 Route 组件的内容。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React from &#x27;react&#x27;</span><br><span class="line">import ReactDOM from &#x27;react-dom&#x27;</span><br><span class="line"></span><br><span class="line">/* </span><br><span class="line">  路由的执行过程</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">import &#123; BrowserRouter as Router, Route, Link &#125; from &#x27;react-router-dom&#x27;</span><br><span class="line"></span><br><span class="line">const First = () =&gt; &lt;p&gt;页面一的内容&lt;/p&gt;</span><br><span class="line">const Home = () =&gt; &lt;h2&gt;这是Home组件的内容&lt;/h2&gt;</span><br><span class="line"></span><br><span class="line">// 使用Router组件包裹整个应用</span><br><span class="line">const App = () =&gt; (</span><br><span class="line">  &lt;Router&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;React路由基础&lt;/h1&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;/* 指定路由出口 */&#125;</span><br><span class="line">        &lt;Route path=&quot;/first&quot; component=&#123;First&#125; /&gt;</span><br><span class="line">        &lt;Route path=&quot;/home&quot; component=&#123;Home&#125; /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &#123;/* 指定路由入口 */&#125;</span><br><span class="line">      &lt;Link to=&quot;/first&quot;&gt;页面一&lt;/Link&gt;</span><br><span class="line">      &lt;br /&gt;</span><br><span class="line">      &lt;Link to=&quot;/home&quot;&gt;首页&lt;/Link&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/Router&gt;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;App /&gt;, document.getElementById(&#x27;root&#x27;))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>10.3、js实现页面跳转和返回上一级以及默认路由</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import ReactDOM from &#x27;react-dom&#x27;;</span><br><span class="line">import &#123; BrowserRouter as Router, Routes, Route, Link, useNavigate &#125; from &#x27;react-router-dom&#x27;;</span><br><span class="line"></span><br><span class="line">// 页面一</span><br><span class="line">const FirstPage = () =&gt; &#123;</span><br><span class="line">  const navigate = useNavigate(); // useNavigate钩子函数用于导航</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h2&gt;这是页面一&lt;/h2&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; navigate(&#x27;/second&#x27;)&#125;&gt;跳转到页面二&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 页面二</span><br><span class="line">const SecondPage = () =&gt; &#123;</span><br><span class="line">  const navigate = useNavigate(); // useNavigate钩子函数用于导航</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h2&gt;这是页面二&lt;/h2&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; navigate(-1)&#125;&gt;返回上一级&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 应用主组件</span><br><span class="line">const App = () =&gt; (</span><br><span class="line">  &lt;Router&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;React 路由示例&lt;/h1&gt;</span><br><span class="line">      &#123;/* 导航链接 */&#125;</span><br><span class="line">      &lt;nav&gt;</span><br><span class="line">        &lt;Link to=&quot;/&quot;&gt;首页&lt;/Link&gt;</span><br><span class="line">        &lt;br /&gt;</span><br><span class="line">        &lt;Link to=&quot;/first&quot;&gt;页面一&lt;/Link&gt;</span><br><span class="line">        &lt;br /&gt;</span><br><span class="line">        &lt;Link to=&quot;/second&quot;&gt;页面二&lt;/Link&gt;</span><br><span class="line">        &lt;br /&gt;</span><br><span class="line"></span><br><span class="line">      &lt;/nav&gt;</span><br><span class="line"></span><br><span class="line">      &#123;/* 路由出口 */&#125;</span><br><span class="line">      &lt;Routes&gt;</span><br><span class="line">        &#123;/* 默认路由 */&#125;</span><br><span class="line">        &lt;Route path=&quot;/&quot; element=&#123;&lt;h2&gt;欢迎来到首页&lt;/h2&gt;&#125; /&gt;</span><br><span class="line">        &#123;/* 指定路由出口 */&#125;</span><br><span class="line">        &lt;Route path=&quot;/first&quot; element=&#123;&lt;FirstPage /&gt;&#125; /&gt;</span><br><span class="line">        &lt;Route path=&quot;/second&quot; element=&#123;&lt;SecondPage /&gt;&#125; /&gt;</span><br><span class="line">      &lt;/Routes&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/Router&gt;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;App /&gt;, document.getElementById(&#x27;root&#x27;));</span><br></pre></td></tr></table></figure>

<h3 id="路由匹配模式"><a href="#路由匹配模式" class="headerlink" title="路由匹配模式"></a>路由匹配模式</h3><p>在React Router v6之前路由默认是模糊匹配模式,即当你定义了一个路径，它将匹配所有以该路径开头的 URL。</p>
<p>要是要使用精确匹配模式需要使用 exact关键字</p>
<p>v6以后没有模糊匹配模式  只有精确匹配 如果需要模糊匹配需要使用通配符进行匹配</p>
<p>精确模式（v6以前）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import &#123; BrowserRouter as Router, Route, Switch, Link &#125; from &#x27;react-router-dom&#x27;;</span><br><span class="line"></span><br><span class="line">const Home = () =&gt; &lt;h2&gt;首页&lt;/h2&gt;;</span><br><span class="line">const About = () =&gt; &lt;h2&gt;关于&lt;/h2&gt;;</span><br><span class="line"></span><br><span class="line">const App = () =&gt; (</span><br><span class="line">  &lt;Router&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;nav&gt;</span><br><span class="line">        &lt;Link to=&quot;/&quot;&gt;首页&lt;/Link&gt; | &lt;Link to=&quot;/about&quot;&gt;关于&lt;/Link&gt;</span><br><span class="line">      &lt;/nav&gt;</span><br><span class="line">      &lt;Switch&gt;</span><br><span class="line">        &#123;/* 精确匹配 */&#125;</span><br><span class="line">        &lt;Route path=&quot;/&quot; exact component=&#123;Home&#125; /&gt;</span><br><span class="line">        &#123;/* 默认模糊匹配 */&#125;</span><br><span class="line">        &lt;Route path=&quot;/about&quot; component=&#123;About&#125; /&gt;</span><br><span class="line">      &lt;/Switch&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/Router&gt;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure>

<p>模糊匹配模式（v6以前）:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import &#123; BrowserRouter as Router, Route, Switch, Link &#125; from &#x27;react-router-dom&#x27;;</span><br><span class="line"></span><br><span class="line">const Home = () =&gt; &lt;h2&gt;首页&lt;/h2&gt;;</span><br><span class="line">const About = () =&gt; &lt;h2&gt;关于&lt;/h2&gt;;</span><br><span class="line"></span><br><span class="line">const App = () =&gt; (</span><br><span class="line">  &lt;Router&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;nav&gt;</span><br><span class="line">        &lt;Link to=&quot;/&quot;&gt;首页&lt;/Link&gt; | &lt;Link to=&quot;/about&quot;&gt;关于&lt;/Link&gt;</span><br><span class="line">      &lt;/nav&gt;</span><br><span class="line">      &lt;Switch&gt;</span><br><span class="line">        &#123;/* 模糊匹配 */&#125;</span><br><span class="line">        &lt;Route path=&quot;/about&quot; component=&#123;About&#125; /&gt;</span><br><span class="line">        &#123;/* 由于没有 `exact`，此路由会匹配以 `/about` 开头的所有路径 */&#125;</span><br><span class="line">        &lt;Route path=&quot;/&quot; component=&#123;Home&#125; /&gt;</span><br><span class="line">      &lt;/Switch&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/Router&gt;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">export default App;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端开发</category>
        <category>Web开发</category>
        <category>JavaScript框架</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>前端开发</tag>
        <tag>JavaScript</tag>
        <tag>Web开发</tag>
      </tags>
  </entry>
</search>
