<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2024/08/27/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>Personal</category>
      </categories>
      <tags>
        <tag>Introduction</tag>
        <tag>Welcome</tag>
      </tags>
  </entry>
  <entry>
    <title>轻量级的日志系统</title>
    <url>/2024/08/28/%E8%BD%BB%E9%87%8F%E7%BA%A7%E7%9A%84%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="轻量级日志系统-Loki-Loki4j-Grafana-实践"><a href="#轻量级日志系统-Loki-Loki4j-Grafana-实践" class="headerlink" title="轻量级日志系统(Loki + Loki4j + Grafana)实践"></a>轻量级日志系统(Loki + Loki4j + Grafana)实践</h1><h2 id="常见的日志监控系统"><a href="#常见的日志监控系统" class="headerlink" title="常见的日志监控系统"></a>常见的日志监控系统</h2><p>平时在构建日志管理系统时，传统的、重量级的ELK Stack当仁不让,除了它之外还有几个常见的选择：</p>
<ul>
<li><p><strong>Splunk</strong>:</p>
<ul>
<li>强大的商业日志管理和分析平台，提供实时搜索、监控和警报功能。</li>
<li>用户界面友好，适用于大规模的日志数据收集和分析需求。</li>
</ul>
</li>
<li><p><strong>Graylog</strong>:</p>
<ul>
<li>开源的日志管理平台，支持实时流式处理和数据分析。</li>
<li>提供强大的搜索和可视化功能，适合中小型企业和开发团队使用。</li>
</ul>
</li>
<li><p><strong>Fluentd</strong>:</p>
<ul>
<li>开源的数据收集器，设计用于大规模数据流处理。</li>
<li>支持灵活的数据传输和转换，可以与多种数据存储系统集成。</li>
</ul>
</li>
<li><p><strong>Prometheus + Grafana</strong>:</p>
<ul>
<li><p>Prometheus是一个开源的监控和警报工具，专注于时序数据的收集和存储。</p>
</li>
<li><p>Grafana作为其可视化和仪表板工具，与Prometheus紧密集成，用于监控数据的可视化展示。</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><em>我今天实践的是由<strong>Grafana Labs</strong>开发的日志聚合系统，它专注于高效率地收集和存储日志，使用标签而不是索引来组织日志数据，使其在大规模环境中更具可扩展性（轻量级）。想我这种叼毛的服务器装上Elasticsearch+Kibana基本就.gg了别说运行程序了了。</em></p>
</blockquote>
<h2 id="所需组件简介"><a href="#所需组件简介" class="headerlink" title="所需组件简介"></a>所需组件简介</h2><p>想要使用轻量级日志系统（Loki + Loki4j + Grafana），首先要理解每个组件的作用和优势：</p>
<h3 id="什么是-Loki？"><a href="#什么是-Loki？" class="headerlink" title="什么是 Loki？"></a>什么是 Loki？</h3><blockquote>
<p><strong>Loki</strong> 是由Grafana Labs开发的开源日志聚合系统，专为高效处理和可视化大规模分布式系统的日志数据而设计。与传统的日志系统不同，Loki使用标签索引而非传统的文档索引存储日志数据，这种方式提升了查询效率和存储效率，尤其适合大规模环境的应用。</p>
</blockquote>
<h3 id="什么是Loki4j？"><a href="#什么是Loki4j？" class="headerlink" title="什么是Loki4j？"></a>什么是Loki4j？</h3><blockquote>
<p><strong>Loki4j</strong> 是专为Java应用程序设计的日志库，用于将应用程序的日志数据发送到Loki服务器。它提供简单的API接口，使得在Java应用中集成Loki变得更加便捷高效，充分利用Loki的强大存储和检索能力。</p>
</blockquote>
<h3 id="什么是Grafana？"><a href="#什么是Grafana？" class="headerlink" title="什么是Grafana？"></a>什么是Grafana？</h3><p>当谈论Grafana时，可以将其描述为一个强大且灵活的开源数据可视化和监控平台。它最初是为了监控系统指标而开发的，但现在已经发展成为支持多种数据源的广泛应用工具。</p>
<blockquote>
<p><strong>Grafana</strong> 是一款开源的数据分析和可视化平台，最初用于监控数据展示和分析。现在，Grafana不仅支持各种数据源（如时序数据库、日志数据库、关系型数据库等），还提供丰富的图表选项和仪表板配置，用户可以通过简单的拖拽操作快速创建和定制监控和分析场景。Grafana还拥有强大的警报功能，帮助用户实时响应数据异常情况。</p>
</blockquote>
<h2 id="实践过程"><a href="#实践过程" class="headerlink" title="实践过程"></a>实践过程</h2><h3 id="1-安装Loki和Grafana"><a href="#1-安装Loki和Grafana" class="headerlink" title="1. 安装Loki和Grafana"></a>1. 安装Loki和Grafana</h3><pre><code>[root@bogon ~]# docker run -d --name loki -p 3100:3100 grafana/loki:latest -config.file=/etc/loki/local-config.yaml
[root@bogon ~]# docker run -d --name grafana -p 3000:3000 grafana/grafana:latest
</code></pre>
<p>有需要的可以将配置、数据和日志文件保存到宿主机。</p>
<blockquote>
<p>grafana组件安装好后可以过127.0.0.1:3000进入操作页面，默认账号密码:admin。</p>
</blockquote>
<p>登录成功以后可以先测试连接loki测试是否连通</p>
<ol>
<li>进入Data Source页面Add data source</li>
</ol>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5e133cdec2b4a57aa8eca282b3b0384~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2533&h=1303&s=307292&e=png&b=191c21" alt="image-20240619172307402.png"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dde9a1393d044bfbbfb71da706a40a4e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2283&h=1146&s=64145&e=png&b=191b20" alt="image-20240619172415963.png"></p>
<ol start="2">
<li>点击后输入框搜索Loki后点击填写数据，填写完成后点击Save &amp; test后</li>
</ol>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/85e55f45bf884fb9a79d699742d127da~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2541&h=1033&s=76315&e=png&b=111217" alt="image-20240619174025971.png"></p>
<h3 id="2-配置Loki4j"><a href="#2-配置Loki4j" class="headerlink" title="2. 配置Loki4j"></a>2. 配置Loki4j</h3><p><strong>引入jar包</strong></p>
<blockquote>
<pre><code>&lt;dependency&gt;
 &lt;groupId&gt;com.github.loki4j&lt;/groupId&gt;
 &lt;artifactId&gt;loki-logback-appender&lt;/artifactId&gt;
 &lt;version&gt;1.4.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
</blockquote>
<p><strong>在src&#x2F;main&#x2F;resources下创建logback.xml</strong></p>
<blockquote>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;configuration&gt;
 &lt;!-- 引入Spring应用名称 --&gt;
 &lt;springProperty scope=&quot;context&quot; name=&quot;name&quot; source=&quot;spring.application.name&quot;/&gt;
 &lt;!-- 控制台输出器 --&gt;
 &lt;appender name=&quot;CONSOLE&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;
     &lt;encoder&gt;
         &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [thread %thread] %-5level %logger&#123;36&#125;.%method - $&#123;name&#125; - %msg%n&lt;/pattern&gt;
     &lt;/encoder&gt;
 &lt;/appender&gt;

 &lt;!-- Loki输出器 --&gt;
 &lt;appender name=&quot;LOKI&quot; class=&quot;com.github.loki4j.logback.Loki4jAppender&quot;&gt;
     &lt;http&gt;
         &lt;url&gt;http://192.168.56.102:3100/loki/api/v1/push&lt;/url&gt;
     &lt;/http&gt;
     &lt;format&gt;
         &lt;label&gt;
             &lt;pattern&gt;application=$&#123;name&#125;,level=%level&lt;/pattern&gt;
             &lt;readMarkers&gt;true&lt;/readMarkers&gt;
         &lt;/label&gt;
         &lt;message&gt;
             &lt;pattern&gt;
                 &#123;&quot;timestamp&quot;: &quot;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;&quot;, &quot;level&quot;: &quot;%level&quot;, &quot;logger&quot;: &quot;%logger&#123;36&#125;.%method&quot;, &quot;method&quot;:&quot;%M&quot;, &quot;line&quot;:&quot;%line&quot;, &quot;thread&quot;: &quot;%thread&quot;, &quot;message&quot;: &quot;%msg%n&quot;&#125;
             &lt;/pattern&gt;
         &lt;/message&gt;
         &lt;sortByTime&gt;true&lt;/sortByTime&gt;
     &lt;/format&gt;
 &lt;/appender&gt;

 &lt;root level=&quot;INFO&quot;&gt;
     &lt;appender-ref ref=&quot;CONSOLE&quot;/&gt;
     &lt;appender-ref ref=&quot;LOKI&quot;/&gt;
 &lt;/root&gt;

&lt;/configuration&gt;
</code></pre>
</blockquote>
<p>在 <strong>application.yml</strong>中</p>
<blockquote>
<pre><code>spring:
application:
 name: blog
</code></pre>
</blockquote>
<p>配置完成后运行程序就可以去garafana查看日志了</p>
<h3 id="3-查看日志"><a href="#3-查看日志" class="headerlink" title="3. 查看日志"></a>3. 查看日志</h3><p>进入garafana按照步骤就可以查看日志了</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/57c43bd3a14e43c7b869228ce8b9a44f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2536&h=1338&s=322720&e=png&b=191c20" alt="image-20240619230211998.png"><br>此外Loki还支持<a href="https://grafana.com/docs/loki/latest/reference/loki-http-api/">HTTP API</a>的形式操作数据,具体的可以看官网文档。</p>
]]></content>
      <categories>
        <category>Java开发</category>
        <category>日志管理</category>
        <category>监控与可视化</category>
        <category>DevOps工具</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>Loki</tag>
        <tag>Loki4j</tag>
        <tag>Grafana</tag>
        <tag>日志管理</tag>
        <tag>可视化</tag>
        <tag>监控工具</tag>
      </tags>
  </entry>
  <entry>
    <title>让你Docker从入门到精通</title>
    <url>/2024/08/28/%E8%AE%A9%E4%BD%A0Docker%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/</url>
    <content><![CDATA[<h1 id="Docker-学习笔记"><a href="#Docker-学习笔记" class="headerlink" title="Docker 学习笔记"></a>Docker 学习笔记</h1><p>[toc]</p>
<h2 id="Docker-简介"><a href="#Docker-简介" class="headerlink" title="Docker 简介"></a>Docker 简介</h2><p>虚拟机（Virtual Machine，简称VM）的发展，减轻了企业对硬件资源的依赖，它将一台物理设备虚拟为多个逻辑设备，每个逻辑设备可运行不同的操作系统，并且应用程序都可以在相互独立的空间内运行而互不影响，从而显著提高设备的工作效率。然而，传统VM需要安装操作系统才能执行应用程序，占用系统资源过多。多数情况下，用户只需要运行简单的应用程序，采用VM技术操作繁琐且造成资源浪费。倘若需要迁移应用服务程序，则需迁移整个VM，因此企业迫切需要轻量级的虚拟化技术。</p>
<p><strong>容器</strong>，就是一种<strong>轻量级</strong>的虚拟化技术，目的和虚拟机一样，都是为了创造 <strong>“隔离环境”</strong> 。但是它不像VM采用操作系统级的<strong>资源隔离</strong>，容器采用的是进程级的<strong>系统隔离</strong>。</p>
<p>容器虚拟化技术化常见的有：Kubernetes（K8s）、Podman、LXC、Rkt、Docker等。基于这个容器的优缺点，我经常使用的是docker。它的优点如下：</p>
<ul>
<li><strong>轻量级和高效</strong>： Docker 利用容器技术，与传统的虚拟机相比，它们共享主机操作系统的内核，因此更为轻量级和高效。Docker 容器启动快速，占用资源较少，能够在短时间内快速部署和销毁。</li>
<li><strong>一致的开发和运行环境</strong>： Docker 提供了一种标准化的打包和交付机制，开发者可以将应用程序及其所有依赖项打包到一个 Docker 镜像中。这种镜像可以在开发、测试和生产环境中一致地运行，消除了由环境差异引起的问题，确保了应用程序的一致性和可移植性。</li>
<li><strong>快速部署和扩展</strong>： Docker 容器可以快速部署到任何支持 Docker 的主机上，并且可以轻松地进行水平扩展。Docker 提供了简单而强大的容器编排工具（如 Docker Swarm 和 Kubernetes），使得多个容器的管理和扩展变得更加简单和高效。</li>
<li><strong>环境隔离和安全性</strong>： 每个 Docker 容器都是相互隔离的，有自己的文件系统、进程空间和网络接口，可以避免应用程序之间的冲突和影响。这种隔离性有助于提高应用程序的安全性，并减少了安全漏洞的风险。</li>
<li><strong>持续集成和持续部署的支持</strong>： Docker 可以与现代的 CI&#x2F;CD 工具集成，自动化构建、测试和部署流程。这使得开发团队能够更快速、可靠地交付新版本的应用程序，提高了软件开发和部署的效率和质量。</li>
<li><strong>开放和生态系统</strong>： Docker 是一个开源项目，并且有一个活跃的社区支持和贡献。它的开放性使得用户可以自由地扩展和定制 Docker 平台，同时有许多第三方工具和服务与 Docker 集成，进一步丰富了其功能和应用场景。</li>
</ul>
<h2 id="Docker常用网站"><a href="#Docker常用网站" class="headerlink" title="Docker常用网站"></a>Docker常用网站</h2><p>常用网站:</p>
<ol>
<li><a href="http://www.docker.com/">docker官网</a></li>
<li><a href="https://www.dockerdocs.cn/index.html">docker中文网</a></li>
<li><a href="https://hub.docker.com/">docker hub</a></li>
<li><a href="https://docs.docker.com/">docker文档</a></li>
</ol>
<p>安装 Docker 引擎版请参考 <a href="https://docs.docker.com/engine/install/">Docker 引擎版安装指南</a></p>
<h2 id="Docker三要素"><a href="#Docker三要素" class="headerlink" title="Docker三要素"></a>Docker三要素</h2><ul>
<li><strong>镜像（Image）</strong> ：镜像是 Docker 容器的模板，包含应用程序和运行环境。通过镜像，可以在不同环境中创建一致的容器。</li>
<li><strong>容器（Container）</strong> ：容器是镜像的运行实例，包含应用程序及其依赖。容器彼此隔离，但共享主机的操作系统内核。</li>
<li><strong>仓库（Repository）</strong> ：仓库用于存储和分发镜像。Docker Hub 是一个公共的镜像仓库，用户可以从中下载和上传镜像。</li>
</ul>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8a99138cf33b4becb0cb5ab84a59ec88~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=835&h=834&s=123134&e=png&b=fdfcfc" alt="image-20240614105028338.png"></p>
<p>废话不多说我们马上来上手来安装<strong>Docker</strong>吧！</p>
<h2 id="安装Docker–centos7示例"><a href="#安装Docker–centos7示例" class="headerlink" title="安装Docker–centos7示例"></a>安装Docker–centos7示例</h2><p><strong>前置条件</strong> ：安装之前首先需要准备一个centos7的虚拟机并且可以连接到网络。</p>
<ol>
<li><p>更新系统软件包首确保所有软件包都是最新的（可选） <code>sudo yum update -y</code></p>
</li>
<li><p>安装必要的依赖包</p>
<p><code>sudo yum install -y yum-utils device-mapper-persistent-data lvm2</code></p>
</li>
<li><p>添加 Docker 仓库</p>
<p><code>sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</code></p>
</li>
<li><p>安装 Docker</p>
<p><code>sudo yum install -y docker-ce docker-ce-cli containerd.io</code></p>
</li>
<li><p>启动 Docker 服务并设置开机自启动</p>
<p><code>sudo systemctl start docker</code> <code>sudo systemctl enable docker</code></p>
</li>
<li><p>验证 Docker 安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo docker run hello-world </span><br></pre></td></tr></table></figure></li>
</ol>
<p>安装成功以后可以看到以下信息</p>
<ol start="7">
<li><p>添加用户到 Docker 组</p>
<p>为了避免每次运行 Docker 命令都使用 <code>sudo</code>，可以将当前用户添加到 Docker 组：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo usermod -aG docker $USER</span><br></pre></td></tr></table></figure>

<p>然后退出并重新登录，或使用 <code>newgrp docker</code> 命令刷新组成员身份。</p>
</li>
<li><p>配置 Docker 镜像加速</p>
<p>为加速 Docker 镜像下载，可以配置国内的镜像源，例如使用阿里云加速器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://&lt;your-mirror-url&gt;&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br><span class="line">&lt;!-- 国内常见镜像源--&gt;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [</span><br><span class="line">  &quot;https://********.mirror.aliyuncs.com&quot;, //阿里云加速器</span><br><span class="line">  &quot;https://dockerproxy.com&quot;,//DockerProxy</span><br><span class="line">  &quot;https://mirror.baidubce.com&quot;,//百度云加速器:</span><br><span class="line">  &quot;https://docker.m.daocloud.io&quot;,//DaoCloud加速器</span><br><span class="line">  &quot;https://docker.nju.edu.cn&quot;,//南京大学加速器</span><br><span class="line">  &quot;https://docker.mirrors.sjtug.sjtu.edu.cn&quot;//上海交通大学加速器</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="Docker底层原理"><a href="#Docker底层原理" class="headerlink" title="Docker底层原理"></a>Docker底层原理</h2><h3 id="到底什么是Docker？Docker-是怎么工作的？"><a href="#到底什么是Docker？Docker-是怎么工作的？" class="headerlink" title="到底什么是Docker？Docker 是怎么工作的？"></a>到底什么是Docker？Docker 是怎么工作的？</h3><p><code>Docker是一个Client-Server结构的系统，Docker守护进程运行在主机上， 然后通过Socket连接从客户端访问Docker守护进程。Docker守护进程从客户端接受命令，并按照命令，管理运行在主机上的容器。</code></p>
<p>Docker 通过使用 Linux 容器技术，提供了一种轻量级的虚拟化解决方案。以下是 Docker 的工作原理概述：</p>
<ol>
<li><p><strong>Namespaces（命名空间）</strong> ：</p>
<ul>
<li>Docker 使用 Linux 的命名空间（Namespaces）技术来实现资源隔离。每个容器都有自己的网络、进程、挂载点、UTS（主机名）和 IPC（进程间通信）命名空间。这些命名空间确保了容器之间的隔离，使得一个容器中的操作不会影响到其他容器。</li>
</ul>
</li>
<li><p><strong>Control Groups（控制组，Cgroups）</strong> ：</p>
<ul>
<li>控制组（Cgroups）是 Linux 内核提供的另一种功能，用于限制、记录和隔离进程组的资源（CPU、内存、磁盘I&#x2F;O、网络等）使用情况。Docker 使用 Cgroups 来管理每个容器可以使用的资源，确保容器之间的资源分配和使用不会相互干扰。</li>
</ul>
</li>
<li><p><strong>Union File Systems（联合文件系统，UnionFS）</strong> ：</p>
<ul>
<li>Docker 利用联合文件系统（如 AUFS、OverlayFS、Btrfs 等）来实现高效的存储层。UnionFS 允许多个文件系统层叠加在一起，形成一个单一的可用文件系统。Docker 镜像由多层组成，每层都可以看作是一个只读的文件系统，容器运行时的写操作会创建一个新的可写层（容器层）。这种层次结构使得镜像的共享和复用变得非常高效。</li>
</ul>
</li>
<li><p><strong>Container Runtime（容器运行时）</strong> ：</p>
<ul>
<li>Docker 使用容器运行时来管理容器的生命周期。Docker 最初使用的是自带的运行时（libcontainer），现在则是基于 OCI 标准的 runc。运行时负责创建和启动容器，并使用上面提到的命名空间和控制组来实现隔离和资源控制。</li>
</ul>
</li>
<li><p><strong>Docker Daemon（守护进程）</strong> ：</p>
<ul>
<li>Docker 守护进程（dockerd）是 Docker 引擎的核心组件，负责处理 Docker API 请求、管理镜像和容器、网络、数据卷等。客户端（如 Docker CLI 或其他工具）通过与 Docker 守护进程通信来管理容器。</li>
</ul>
</li>
<li><p><strong>Docker 镜像和容器</strong>：</p>
<ul>
<li>Docker 镜像是容器的蓝图，包含了运行应用程序所需的一切（代码、库、配置文件等）。Docker 容器是镜像的运行实例，每个容器都是一个独立的进程，具有自己的文件系统、网络接口和资源限制。</li>
</ul>
</li>
</ol>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f67f182a6d5749928ac2b2f4e193c5d0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=732&h=711&s=128228&e=png&b=ffffff" alt="1718675370435.jpg"></p>
<h3 id="Docker为什么比VM虚拟机快"><a href="#Docker为什么比VM虚拟机快" class="headerlink" title="Docker为什么比VM虚拟机快"></a>Docker为什么比VM虚拟机快</h3><p>Docker 相对于传统的虚拟机有显著的性能优势，主要原因如下：</p>
<ol>
<li><p><strong>共享主机操作系统内核</strong>：</p>
<ul>
<li>Docker 容器共享主机操作系统的内核，而虚拟机则需要运行一个完整的客操作系统。共享内核减少了内存和 CPU 的开销，提高了资源利用效率。</li>
</ul>
</li>
<li><p><strong>轻量级的进程隔离</strong>：</p>
<ul>
<li>Docker 使用的是进程级别的隔离技术，而虚拟机需要虚拟化整个硬件环境。这使得 Docker 容器的启动和停止速度非常快，通常只需几秒钟甚至几毫秒，而虚拟机则需要几分钟。</li>
</ul>
</li>
<li><p><strong>更高的资源利用率</strong>：</p>
<ul>
<li>由于 Docker 容器不需要为每个实例分配固定的资源（如 CPU、内存等），而是通过控制组动态管理，这使得资源利用率更高。虚拟机通常需要预分配资源，即使未完全使用，资源也会被占用。</li>
</ul>
</li>
<li><p><strong>高效的存储层</strong>：</p>
<ul>
<li>Docker 的联合文件系统使得镜像的存储和传输非常高效。只需下载和存储不同层的差异部分即可，这相比虚拟机需要完整的磁盘镜像文件要高效得多。</li>
</ul>
</li>
<li><p><strong>一致的环境</strong>：</p>
<ul>
<li><p>Docker 提供了一致的运行环境，消除了开发、测试和生产环境之间的差异，减少了环境配置和依赖问题，从而提高了开发和部署的效率。</p>
<p>| 特性     | 容器     | 虚拟机   |<br> | ——– | ——– | ——– |<br>| 启动速度 | 秒级     | 分钟级   |<br>| 硬盘使用 | 一般为MB | 一般为GB |<br>| 性能     | 接近原生 | 弱于原生 |</p>
</li>
</ul>
</li>
</ol>
<p>Docker 虽然在许多方面优于传统的虚拟机（VM），但也存在一些缺点：</p>
<ol>
<li><strong>操作系统依赖性</strong>：</li>
</ol>
<ul>
<li>Docker 容器共享宿主机的操作系统内核，这意味着容器化的应用程序必须与宿主机的操作系统兼容。如果应用程序依赖于特定版本或配置的操作系统，容器化可能会面临限制或兼容性问题。</li>
</ul>
<ol start="2">
<li><strong>安全性</strong>：</li>
</ol>
<ul>
<li>虽然 Docker 提供了一定程度的隔离性，但容器共享相同的内核和部分系统资源，这可能导致容器间的安全漏洞扩散。相比之下，虚拟机能够提供更加彻底的隔离，每个虚拟机都有自己的完整操作系统。</li>
</ul>
<ol start="3">
<li><strong>性能开销</strong>：</li>
</ol>
<ul>
<li>Docker 容器在运行时不需要启动整个操作系统，因此通常比虚拟机启动更快并且资源消耗更少。然而，Docker 容器仍然有一定的性能开销，尤其是在涉及密集的计算或需要大量 I&#x2F;O 操作时，性能可能不如直接在物理或虚拟机上运行的应用程序。</li>
</ul>
<ol start="4">
<li><strong>持久化存储</strong>：</li>
</ol>
<ul>
<li>Docker 容器默认情况下使用的是可写的容器层（Container Layer），这些层不适合长期存储或大量写入操作。虽然可以通过数据卷（Volumes）或者其他存储解决方案来解决这个问题，但这增加了部署和管理的复杂性。</li>
</ul>
<ol start="5">
<li><strong>复杂性和学习曲线</strong>：</li>
</ol>
<ul>
<li>虽然 Docker 提供了强大的功能和灵活性，但学习如何正确地使用 Docker 和管理容器化应用程序需要一定的学习和适应时间。尤其是对于复杂的网络配置、容器编排和持续集成&#x2F;持续部署（CI&#x2F;CD）流程，需要额外的专业知识和经验。</li>
</ul>
<ol start="6">
<li><strong>依赖于外部服务</strong>：</li>
</ol>
<ul>
<li>使用 Docker 需要依赖于 Docker Hub 或者其他容器镜像仓库来获取和管理镜像。如果依赖的镜像源不稳定或者出现问题，可能会影响到应用程序的部署和运行。</li>
</ul>
<h2 id="Docker常用命令"><a href="#Docker常用命令" class="headerlink" title="Docker常用命令"></a>Docker常用命令</h2><h3 id="容器管理"><a href="#容器管理" class="headerlink" title="容器管理"></a>容器管理</h3><ul>
<li><p><strong>docker ps</strong> 查看当前正在运行的容器。</p>
</li>
<li><p><strong>docker create <container_id or container_name></strong> ** 创建容器</p>
</li>
<li><p><strong>docker ps -a</strong> 查看所有容器，包括已停止的。</p>
</li>
<li><p><strong>docker start <container_id or container_name></strong> 启动一个停止状态的容器。</p>
</li>
<li><p><strong>docker stop <container_id or container_name></strong> 停止一个运行中的容器。</p>
</li>
<li><p><strong>docker restart <container_id or container_name></strong> 重启一个容器。</p>
</li>
<li><p><strong>docker pause <container_id or container_name></strong></p>
<p>暂停一个或多个正在运行的容器中的所有进程。</p>
</li>
<li><p><strong>docker rm <container_id or container_name></strong> 删除一个停止状态的容器。</p>
</li>
<li><p><strong>docker logs <container_id or container_name></strong> 查看容器的日志。</p>
</li>
<li><p><strong>docker exec -it <container_id or container_name> &#x2F;bin&#x2F;bash</strong> 进入正在运行的容器内部的交互式 shell。</p>
</li>
</ul>
<h3 id="镜像管理"><a href="#镜像管理" class="headerlink" title="镜像管理"></a>镜像管理</h3><ul>
<li><strong>docker images</strong> 查看本地所有的镜像。</li>
<li><strong>docker pull <a href="">image_name:tag</a></strong> 拉取一个镜像到本地。</li>
<li><strong>docker build -t <a href="">image_name:tag</a> <Dockerfile_path></strong> 根据 Dockerfile 构建一个镜像。</li>
<li><strong>docker rmi <image_id or image_name:tag></strong> 删除一个本地的镜像。</li>
<li><strong>docker tag <image_id> <a href="">new_image_name:tag</a></strong> 给镜像打标签。</li>
</ul>
<h3 id="网络管理"><a href="#网络管理" class="headerlink" title="网络管理"></a>网络管理</h3><ul>
<li><strong>docker network ls</strong> 列出所有 Docker 网络。</li>
<li><strong>docker network inspect <network_id or network_name></strong> 查看指定 Docker 网络的详细信息。</li>
<li><strong>docker network create <network_name></strong> 创建一个新的 Docker 网络。</li>
<li><strong>docker network connect <network_id or network_name> <container_id or container_name></strong> 连接容器到指定的网络。</li>
</ul>
<h3 id="数据卷管理"><a href="#数据卷管理" class="headerlink" title="数据卷管理"></a>数据卷管理</h3><ul>
<li><strong>docker volume ls</strong> 列出所有 Docker 数据卷。</li>
<li><strong>docker volume create <volume_name></strong> 创建一个新的 Docker 数据卷。</li>
<li><strong>docker volume inspect <volume_name></strong> 查看指定 Docker 数据卷的详细信息。</li>
<li><strong>docker volume rm <volume_name></strong> 删除一个 Docker 数据卷。</li>
</ul>
<h3 id="其他常用命令"><a href="#其他常用命令" class="headerlink" title="其他常用命令"></a>其他常用命令</h3><ul>
<li><strong>docker info</strong> 查看 Docker 系统信息，包括容器和镜像的数量等。</li>
<li><strong>docker version</strong> 查看 Docker 版本信息。</li>
<li><strong>docker-compose up</strong> 使用 Docker Compose 启动应用程序。</li>
<li><strong>docker-compose down</strong> 使用 Docker Compose 停止并移除容器、网络和数据卷。</li>
</ul>
<h2 id="Docker镜像原理"><a href="#Docker镜像原理" class="headerlink" title="Docker镜像原理"></a>Docker镜像原理</h2><p>镜像是一种轻量级、可执行的独立软件包， 用来打包软件运行环境和基于运行环境开发的软件 ，它包含运行某个软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件。  Docker镜像基础是UnionFS联合文件系统，一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层叠加，同时可以将不同目录挂载到同一个虚拟文件系统下，镜像可以通过分层来进行继承，基于继承镜像可以制作各种具体的应用镜像。  特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录。</p>
<h3 id="1-镜像结构"><a href="#1-镜像结构" class="headerlink" title="1. 镜像结构"></a>1. 镜像结构</h3><p>Docker 镜像是一个多层文件系统，每一层都是一个只读文件系统。这些层次结构被称为联合文件系统（UnionFS），允许将多个文件系统层叠在一起，形成一个单一的逻辑文件系统。</p>
<h3 id="2-分层结构"><a href="#2-分层结构" class="headerlink" title="2. 分层结构"></a>2. 分层结构</h3><p>Docker 镜像的每一层都是一个文件系统的快照，包含了构成镜像的文件和目录。每个镜像都有一个基础层（Base Layer），在其基础上可以叠加多个只读层。</p>
<h3 id="3-镜像加载过程"><a href="#3-镜像加载过程" class="headerlink" title="3. 镜像加载过程"></a>3. 镜像加载过程</h3><p>当使用 <code>docker run</code> 命令启动一个容器时，Docker 容器运行时会执行以下步骤来加载镜像：</p>
<ul>
<li><strong>查找镜像：</strong> Docker 首先检查本地是否已经存在所需镜像。如果本地不存在，它会从默认的镜像注册表（如 Docker Hub）下载镜像。</li>
<li><strong>创建容器层：</strong> Docker 创建一个新的容器层（Container Layer），这是一个可写的层，用于存储容器运行时的所有变更和修改。这个层是镜像层的顶部。</li>
<li><strong>联合文件系统：</strong> Docker 将镜像的各个只读层和容器层通过联合文件系统（UnionFS）技术进行联合挂载。这样，容器就能够看到镜像中所有层次的文件系统，但只能修改和操作容器层上的文件系统。</li>
<li><strong>启动容器进程：</strong> 最后，Docker 启动容器中定义的进程，该进程在容器的隔离环境中运行。这个进程可以访问整个联合文件系统，并且只能在容器层进行写操作。</li>
</ul>
<h3 id="4-优势和效率"><a href="#4-优势和效率" class="headerlink" title="4. 优势和效率"></a>4. 优势和效率</h3><p>Docker 镜像加载的这种分层结构和联合文件系统带来了以下优势：</p>
<ul>
<li><strong>资源共享和节约：</strong> 多个容器可以共享相同的基础层（Base Layer），节省存储空间和带宽。</li>
<li><strong>高效构建和部署：</strong> Docker 可以快速创建和销毁容器，因为它只需在容器层上应用变更，而不必重新复制整个镜像。</li>
<li><strong>可复用性和版本控制：</strong> 镜像的分层结构允许开发人员创建和管理不同版本的镜像，并在不同环境中重复使用。</li>
</ul>
<p>Docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS。  bootfs(boot file system)主要包含bootloader和kernel, bootloader主要是引导加载kernel, Linux刚启动时会加载bootfs文件系统， 在Docker镜像的最底层是bootfs。 这一层与我们典型的Linux&#x2F;Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs。</p>
<p>rootfs (root file system) ，在bootfs之上 。包含的就是典型 Linux 系统中的 &#x2F;dev, &#x2F;proc, &#x2F;bin, &#x2F;etc 等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu，Centos等等。</p>
<h3 id="Docker镜像加载原理："><a href="#Docker镜像加载原理：" class="headerlink" title="Docker镜像加载原理："></a><strong>Docker镜像加载原理：</strong></h3><p>Docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS。  bootfs(boot file system)主要包含bootloader和kernel, bootloader主要是引导加载kernel, Linux刚启动时会加载bootfs文件系统， 在Docker镜像的最底层是bootfs。 这一层与我们典型的Linux&#x2F;Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs。 rootfs (root file system) ，在bootfs之上 。包含的就是典型 Linux 系统中的 &#x2F;dev, &#x2F;proc, &#x2F;bin, &#x2F;etc 等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu，Centos等等。</p>
<p>平时我们安装进虚拟机的CentOS都是好几个G，为什么docker这里才200M？？ 对于一个精简的OS，rootfs可以很小，只需要包括最基本的命令、工具和程序库就可以了，因为底层直接用Host的kernel，自己只需要提供 rootfs 就行了。由此可见对于不同的linux发行版, bootfs基本是一致的, rootfs会有差别, 因此不同的发行版可以公用bootfs。 平时我们安装进</p>
<p>虚拟机的CentOS都是好几个G，为什么docker这里才200M？？ 对于一个精简的OS，rootfs可以很小，只需要包括最基本的命令、工具和程序库就可以了，因为底层直接用Host的kernel，自己只需要提供 rootfs 就行了。由此可见对于不同的linux发行版, bootfs基本是一致的, rootfs会有差别, 因此不同的发行版可以公用bootfs。</p>
<h3 id="Docker分层结构的优势"><a href="#Docker分层结构的优势" class="headerlink" title="Docker分层结构的优势"></a><strong>Docker分层结构的优势</strong></h3><p>最大的一个好处就是 - 共享资源 比如：有多个镜像都从相同的 base 镜像构建而来，那么宿主机只需在磁盘上保存一份base镜像，同时内存中也只需加载一份 base 镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。 <strong>Docker镜像</strong>都是<strong>只读</strong>的，当容器启动时，一个新的可写层被加载到镜像的顶部。这一层通常被称作“容器层”，“容器层”之下的都叫“镜像层”。</p>
<h3 id="从容器生成镜像"><a href="#从容器生成镜像" class="headerlink" title="从容器生成镜像"></a><strong>从容器生成镜像</strong></h3><ul>
<li><p><strong>docker commit -m&#x3D;“提交的描述信息” -a&#x3D;“作者” 容器ID 要创建的目标镜像名:[标签名]</strong></p>
<p><code>docker commit -m=&quot;DLF commit test&quot; -a=&quot;DLF&quot; a2ec9eb0e4f3 helloword:v1</code></p>
</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc3b8ac5835a470ba61bf3ba96a61123~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1284&h=750&s=902899&e=png&b=1b3142" alt="image-20240618102758218.png"></p>
<h2 id="数据共享–容器数据卷"><a href="#数据共享–容器数据卷" class="headerlink" title="数据共享–容器数据卷"></a>数据共享–容器数据卷</h2><p>为了能让docker容器产生的数据，如果不做特殊处理，容器删除后，数据也会被删除，可以通过commit或者docker cp这种笨重的方式保存，但更便捷的方法是创建数据卷。 docker容器数据卷有以下特点：</p>
<ol>
<li>数据卷可在容器之间共享或重用数据</li>
<li>卷中的更改可以直接生效</li>
<li>数据卷中的更改不会包含在镜像的更新中</li>
<li>数据卷的生命周期一直持续到没有容器使用它为止</li>
<li>数据卷允许容器数据持久化到宿主机上</li>
</ol>
<h3 id="命令创建容器数据卷"><a href="#命令创建容器数据卷" class="headerlink" title="命令创建容器数据卷"></a><strong>命令创建容器数据卷</strong></h3><ul>
<li>docker run -it -v &#x2F;宿主机绝对路径目录:&#x2F;容器内目录 镜像名:镜像标签</li>
</ul>
<p>可以使用docker inspect 查看是否创建成功</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/42afefd424544397974acd18e68ba4e4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=723&h=228&s=42812&e=png&b=ffffff" alt="image-20240618103323922.png"><br>上述命令可增加读写权限：  docker run -it -v &#x2F;宿主机绝对路径目录:&#x2F;容器内目录:ro 镜像名:镜像标签  <strong>需要注意</strong>的是，-v主机目录的方式，在dockerfile中不能直接使用，由于宿主机是不同的，每个宿主机都不一样，不能保证所有的宿 主机上都存在这样的特定目录。</p>
<h3 id="使用dockerfile创建容器数据卷"><a href="#使用dockerfile创建容器数据卷" class="headerlink" title="使用dockerfile创建容器数据卷"></a><strong>使用dockerfile创建容器数据卷</strong></h3><p>在dockerfile中使用VOLUME指令来给镜像添加一个或多个数据卷</p>
<p>Dockerfile:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 基于官方的 Ubuntu 镜像作为基础镜像</span><br><span class="line">FROM ubuntu:latest</span><br><span class="line"># 设置工作目录</span><br><span class="line">WORKDIR /app</span><br><span class="line"># 在 Dockerfile 中声明多个数据卷</span><br><span class="line">VOLUME [&quot;/app/data1&quot;, &quot;/app/data2&quot;]</span><br><span class="line"># 设置容器启动时执行的命令</span><br><span class="line">CMD [&quot;bash&quot;]</span><br></pre></td></tr></table></figure>

<p>进入Dockerfile所在目录<code>docker build -t myimage .</code></p>
<p><strong>使用 <code>VOLUME</code> 指令声明的数据卷默认情况下是匿名的，即不会显示具体的宿主机路径，但会显示容器内路径。如果你希望在容器运行时能够看到宿主机路径，需要在运行容器时使用 <code>-v</code> 参数来显式挂载。</strong></p>
<p><code>docker run -it -v /host/path/data1:/app/data1 -v /host/path/data2:/app/data2 myimage</code></p>
<p>查看<code>` docker inspect 容器ID</code></p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bde5adc6a0d44502ada523e93616c557~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=394&h=150&s=66605&e=png&b=2b4d60" alt="image-20240618111111078.png"></p>
<h2 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h2><p>命名的容器挂载数据卷，其它容器通过挂载这个(父容器)实现数据共享，挂载数据卷的容器，称之为数据卷容器 ，数据卷的生命周期一直持续到没有容器使用它为止。</p>
<p>我们可以使用上面dockerfile构建的镜像，先启动一个容器myimage,然后再使用以下命令启动两个容器dlf2和dlf1，能看到都有共同的数据卷，在里面创建的文件，再返回myimage查看能被看到：</p>
<p><code>docker run -it --name dlf1 --volumes-from 3f457cfbe5e5 myimage</code></p>
<p><code>docker run -it --name dlf2 --volumes-from 3f457cfbe5e5 myimage</code></p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/771e44e8b7d74fc28b0ce9dfe31c279f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=597&h=75&s=51623&e=png&b=2d5064" alt="image-20240618112300250.png"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7256771dd67b4d1bb91be54036990f31~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=717&h=133&s=64417&e=png&b=2f5267" alt="image-20240618112326425.png"></p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/47a5f7af5fb64b48bd4c822beacc8771~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=676&h=190&s=103412&e=png&b=2d5064" alt="image-20240618112336122.png"></p>
<h2 id="Dockerfile解析"><a href="#Dockerfile解析" class="headerlink" title="Dockerfile解析"></a>Dockerfile解析</h2><p>Dockerfile是用来构建Docker镜像的构建文件，是由一系列命令和参数构成的脚本。 可以理解成可以一键构建镜像的脚本，编写完dockerfile后，docker build 产出镜像，docker run运行镜像</p>
<p>以下是Centos7Dockerfile请参考</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FROM scratch</span><br><span class="line">ADD centos-7-x86_64-docker.tar.xz /</span><br><span class="line"></span><br><span class="line">LABEL \</span><br><span class="line">    org.label-schema.schema-version=&quot;1.0&quot; \</span><br><span class="line">    org.label-schema.name=&quot;CentOS Base Image&quot; \</span><br><span class="line">    org.label-schema.vendor=&quot;CentOS&quot; \</span><br><span class="line">    org.label-schema.license=&quot;GPLv2&quot; \</span><br><span class="line">    org.label-schema.build-date=&quot;20201113&quot; \</span><br><span class="line">    org.opencontainers.image.title=&quot;CentOS Base Image&quot; \</span><br><span class="line">    org.opencontainers.image.vendor=&quot;CentOS&quot; \</span><br><span class="line">    org.opencontainers.image.licenses=&quot;GPL-2.0-only&quot; \</span><br><span class="line">    org.opencontainers.image.created=&quot;2020-11-13 00:00:00+00:00&quot;</span><br><span class="line"></span><br><span class="line">CMD [&quot;/bin/bash&quot;]</span><br></pre></td></tr></table></figure>

<h3 id="Dockerfile语法规则"><a href="#Dockerfile语法规则" class="headerlink" title="Dockerfile语法规则"></a><strong>Dockerfile语法规则</strong></h3><ol>
<li>每条保留字指令都必须为大写字母，且后面要跟随至少一个参数</li>
<li>指令按照从上到下，顺序执行</li>
<li>#表示注释</li>
<li>每条指令都会创建一个新的镜像层，并对镜像进行提交</li>
</ol>
<h3 id="Docker执行Dockerfile的大致流程"><a href="#Docker执行Dockerfile的大致流程" class="headerlink" title="Docker执行Dockerfile的大致流程"></a><strong>Docker执行Dockerfile的大致流程</strong></h3><ol>
<li>docker 从基础镜像运行一个容器</li>
<li>执行一条指令并对容器作出修改</li>
<li>执行类似docker commit的操作提交一个新的镜像层</li>
<li>基于刚提交的镜像运行一个新的容器</li>
<li>执行dockerfile中的下一条指令直到所有指令都执行完成</li>
</ol>
<h3 id="一张图展示dockerfile-image-container等之间关系"><a href="#一张图展示dockerfile-image-container等之间关系" class="headerlink" title="一张图展示dockerfile,image,container等之间关系"></a>一张图展示dockerfile,image,container等之间关系</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2714f1b0d27e41398fc2eaae6fd4d5e4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1149&h=927&s=740724&e=png&b=eeeeee" alt="image-20240618113252050.png"></p>
<h2 id="Docker容器编排"><a href="#Docker容器编排" class="headerlink" title="Docker容器编排"></a>Docker容器编排</h2><p>一般来说，我们每一个容器中只运行一个服务，多个服务时通常需要其他措施来对多个服务保活。因为docker容器本身占用资源极少,所以最好是将每个服务单独的分割开来但是这样我们又面临了一个问题？</p>
<p>如果我需要同时部署好多个服务,难道要每个服务单独写Dockerfile然后在构建镜像,构建容器,这样累都累死了,所以docker官方给我们提供了docker-compose多服务部署的工具 ，可以管理多个 Docker 容器组成一个应用。你需要定义一个 YAML 格式的配置文件docker-compose.yml， 写好多个容器之间的调用关系 。然后，只要一个命令，就能同时启动&#x2F;关闭这些容器</p>
<p>例如要实现一个Web微服务项目，除了Web服务容器本身，往往还需要再加上后端的数据库mysql服务容器，redis服务器，注册中心eureka，甚至还包括负载均衡容器等等。。。。。。</p>
<p>Compose允许用户通过一个单独的 docker-compose.yml模板文件 （YAML 格式）来定义 一组相关联的应用容器为一个项目（project）。</p>
<p>可以很容易地用一个配置文件定义一个多容器的应用，然后使用一条指令安装这个应用的所有依赖，完成构建。Docker-Compose 解决了容器与容器之间如何管理编排的问题。</p>
<p>安装地址：<a href="https://docs.docker.com/compose/install/linux/#install-the-plugin-manually">https://docs.docker.com/compose/install/linux/#install-the-plugin-manually</a></p>
<p><strong>使用步骤</strong></p>
<ol>
<li>编写Dockerfile定义各个微服务应用并构建出对应的镜像文件</li>
<li>使用 docker-compose.yml 定义一个完整业务单元，安排好整体应用中的各个容器服务。</li>
<li>最后，执行docker-compose up命令 来启动并运行整个应用程序，完成一键部署上线</li>
</ol>
<p><strong>常用命令</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Compose 常用命令</span><br><span class="line">docker-compose -h # 查看帮助</span><br><span class="line">docker-compose up # 启动所有 docker-compose服务</span><br><span class="line">docker-compose up -d # 启动所有 docker-compose服务 并后台运行</span><br><span class="line">docker-compose down # 停止并删除容器、网络、卷、镜像。</span><br><span class="line">docker-compose exec yml里面的服务id # 进入容器实例内部 docker-compose exec docker-compose.yml文件中写的服务id /bin/bash</span><br><span class="line">docker-compose ps # 展示当前docker-compose编排过的运行的所有容器</span><br><span class="line">docker-compose top # 展示当前docker-compose编排过的容器进程</span><br><span class="line"></span><br><span class="line">docker-compose logs yml里面的服务id # 查看容器输出日志</span><br><span class="line">docker-compose config # 检查配置</span><br><span class="line">docker-compose config -q # 检查配置，有问题才有输出</span><br><span class="line">docker-compose restart # 重启服务</span><br><span class="line">docker-compose start # 启动服务</span><br><span class="line">docker-compose stop # 停止服务</span><br></pre></td></tr></table></figure>

<p>安装docker-compose</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">下载 Docker Compose：</span><br><span class="line">sudo curl -L &quot;https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose</span><br><span class="line">赋予执行权限：</span><br><span class="line">sudo chmod +x /usr/local/bin/docker-compose</span><br><span class="line">验证安装：</span><br><span class="line">docker-compose --version</span><br></pre></td></tr></table></figure>

<h3 id="docker-compose案例"><a href="#docker-compose案例" class="headerlink" title="docker-compose案例"></a>docker-compose案例</h3><p>首先在docker路径下创建以上文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@bogon docker]# ls</span><br><span class="line">default.conf  docker-compose.yml  nginx.conf  website</span><br><span class="line">[root@bogon docker]# pwd</span><br><span class="line">/docker</span><br></pre></td></tr></table></figure>

<p><strong>nginx.conf</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># nginx.conf</span><br><span class="line"></span><br><span class="line">user nginx;</span><br><span class="line">worker_processes auto;</span><br><span class="line">error_log /var/log/nginx/error.log;</span><br><span class="line">pid /run/nginx.pid;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections 1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include /etc/nginx/mime.types;</span><br><span class="line">    default_type application/octet-stream;</span><br><span class="line"></span><br><span class="line">    log_format main &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br><span class="line">                      &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br><span class="line">                      &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><br><span class="line"></span><br><span class="line">    access_log /var/log/nginx/access.log main;</span><br><span class="line"></span><br><span class="line">    sendfile on;</span><br><span class="line">    tcp_nopush on;</span><br><span class="line">    tcp_nodelay on;</span><br><span class="line"></span><br><span class="line">    keepalive_timeout 65;</span><br><span class="line"></span><br><span class="line">    include /etc/nginx/conf.d/*.conf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>docker-compose.yml</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">version: &#x27;3&#x27;</span><br><span class="line">services:</span><br><span class="line">  nginx:</span><br><span class="line">    image: nginx:latest</span><br><span class="line">    container_name: nginx-container</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;80:80&quot;</span><br><span class="line">    volumes:</span><br><span class="line">      - ./default.conf:/etc/nginx/conf.d/default.conf</span><br><span class="line">      - ./website:/usr/share/nginx/html</span><br><span class="line">    restart: always</span><br></pre></td></tr></table></figure>

<p><strong>default.conf</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># default.conf</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;          # Listen on port 80 for incoming HTTP requests</span><br><span class="line">    server_name example.com;  # Server name that this block will respond to</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        root /usr/share/nginx/html;  # Root directory for serving static files</span><br><span class="line">        index index.html;            # Default file to serve if none specified</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>&#x2F;docker&#x2F;website&#x2F;index.html</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;&lt;body&gt;Hello, Docker!&lt;/body&gt;&lt;/html&gt;</span><br></pre></td></tr></table></figure>


<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98f00ad84df742a4b8683c902cd14350~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1656&h=196&s=251693&e=png&b=2b4d60" alt="image-20240618123029300.png"></p>
<p>最后输入<a href="http://192.168.56.102/">http://192.168.56.102/</a>就可以查看到网页了</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb9f7780311e48d98cbe38f757208f82~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2554&h=628&s=35206&e=png&b=fffefe" alt="image-20240618123109978.png"></p>
<p><strong>在容器数量较少的场景下</strong>，我们docker-compose工具已经够用，但如果<strong>容器数量较多</strong>的情况下，我们就需要用一个更便捷的管理工具<strong>k8s</strong>了。</p>
]]></content>
      <categories>
        <category>DevOps工具</category>
        <category>云计算</category>
        <category>运维</category>
      </categories>
      <tags>
        <tag>云技术</tag>
        <tag>Linux</tag>
        <tag>Docker</tag>
        <tag>容器技术</tag>
        <tag>DevOps</tag>
      </tags>
  </entry>
</search>
